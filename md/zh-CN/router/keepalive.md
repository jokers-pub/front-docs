## 路由状态保持 [keepalive]

本章主要介绍下路由状态保持是什么，以及我们如何去使用它。

### 什么是路由状态保持

在开发单页面应用程序（SPA）时，我们常遇到用户从一个列表页面切换到详情页面的情况。返回列表页面时，我们希望保持列表的查询条件、分页状态及其他交互特性不变，避免重新渲染整个列表页面。这个时候就需要我们对某一个页面做路由状态保持，以便它在跳出时不被完整销毁。

### 如何使用

我们可以在路由注册时配置该路由项的`keepalive`项，将该属性设置为`true`/`'once'`即可实现路由的状态保持。不同的配置类型代表的含义不同（**默认 undefined**）：

- `true`: 一直保持存活，可以通过[跳转](/router/change)时使用 **refresh** 属性进行缓存销毁刷新。

- `'once'`:代表只存活一次，该组件只会从缓存中渲染一次，第二次渲染时则按照新组件执行，一般适用于`高频访问+低频更新`的路由节点。

- `false/undefined`: 代表不做状态保持。

```ts
new Router({
    routes: [
        {
            path: "/product/index",
            component: IndexComponent,
            keepalive: true
        }
    ]
});
```

### 如何清除状态

当我们需要刷新已经保持状态的页面时，我们可以通过`push`方法中的**refresh:true**来刷新目标路由的缓存状态。

```ts
push({
    path: "#product/list",
    refresh: true
});
```

> 当然你也可以不清除缓存使用`sleeped、wakeup`两个[生命周函数](/base/component-lifecycle)去实现组件内的数据刷新操作。使用`refresh`可以实现缓存的组件实例的销毁和重新创建。

### once 使用场景

首先当我们配置`keepalive`等于**once**时，该页面只会被缓存一次，我们可以在以下场景下通过`once`来实现比较高效简单的状态保持功能。

1. 该页面是一个高频访问/低频更新的页面，我们可以使用 once 来减少页面渲染次数。
2. 如果我们的下一级路由只能返回到当前页面，也就是说当前的页面链条是单一的，那么我们可以使用`once`来实现状态保持。

其中在链条单一的模式下，我们使用 once，可以免去我们跳转时的`refresh`，因为当我们在此正序访问该页面时，该页面已经不存在缓存状态了。

当然，你也可以根据这种缓存策略拓展出更多应用场景，等待你去探索和发掘。

有些同学可能会有疑问，为什么不可以根据路由跳转方向主动清除缓存。实际上，浏览器在处理跳转时并不会让我们获取到用户的交互历史，因此我们无法确定当前的跳转是用户返回还是前往新的页面。

尽管我们可以在`window`对象中设置一个全局变量来记录每次路由变更的情况，以此在下次跳转时判断历史记录中是否存在目标地址，从而判断是回退还是前进。但这种方法并不可取，因为相同的地址可能既是一次回退，也可能是一个全新的业务节点。不同的页面可能跳转到相同的地址，但它们所代表的业务逻辑是不同的。因此，我们不推荐通过自定义历史记录的方式来管理路由的跳转方向。

因此，在处理复杂的路由跳转场景时，我们建议采用`refresh`属性来决定是否清除缓存状态，这样的方法更为灵活和可控。
