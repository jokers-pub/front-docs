## 列表渲染

该章节将介绍下如何在`template`中实现循环逻辑。

### for(let .. of ..)

使用`for..of`可以快速的遍历数组/对象中的所有项/值，它的用法和`javascript`中的使用方式一致

```xml
<template>
    @for(let item of list){
        <p>@item</p>
    }
    @for(let item of obj){
        <p>@item</p>
    }
</template>
```

```html
<script>
    import { Component } from "@joker.front/core";

    export default class extends Component {
        list = ["张三", "李四", "王五",...];

        obj:{
            userName:"张三",
            age:12
        }
    }
</script>
```

!!!demo1!!!

通过上面的例子可以看到，我们可以在 for 循环中使用`let`定义了一个**item**属性，该属性只会在`for`代码块中生效。
通过下面的例子再看一下值的定义生效范围：

!!!demo2!!!

### fro(let .. in ..)

`for..in`指令，它也是一种循环命令，它区别于`for..of`，它循环的值是对象/数组的**索引**。

同样的例子，我们看一下**for...in**的输出结果：

!!!demo3!!!

通过上面的例子可以看到，我们使用`let`定义的**item**，在循环过程中代表每一项的索引，当然我们也可以在`for`代码块中使用表达式，来完成值的输出：

```xml
@for(let item in list){
    <p>@list[item]</p>
}
```

!!!demo4!!!

除此上述使用方式外，我们也提供了一种全参数的循环语法：

```xml
@for(let (index,item) in list){
    <p>@list[index] ===  @item</p>
}
```

当 let 的值为`()`规则时，我们会将第一个参数作为 index 索引 key，第二个参数作为 item 项的 key。该用法只可以在`for in`指令中使用。

### for(..;..;..)

除了上述两种常用的循环指令，我们也提供了自定义表达式循环，我们可以使用自定义表达式完成更加复杂的循环。

例如：

!!!demo5!!!

> 我们不建议在表达式中对非 for 循环定义的值进行修改。

### 深入原理

该小结我们主要介绍下，循环列表的数据响应机制以及节点更新机制。

由于`Joker`数据响应处理是 VNode 关联实际输出节点，数据的变更会即时响应节点的变更操作，当我们对某一项进行修改时，最终也只会有一条 DOM 节点的变更操作被执行，无变更的节点不会执行更新操作。

!!!demo6!!!

当需要循环的列表/对象变更时`（长度）`，我们会从头进行一次循环，将循环的 **值** 与已经渲染的值进行对比，若相同则不执行 **Render** 渲染，若有变更则销毁以渲染的节点，并插入新的节点；当循环结束后，会将 **多出来的(本次渲染长度小于原长度)** 进行销毁操作。值的注意的是，我们刚才提到的 **值对比** 是指 **表达式的值** 而非虚拟 DOM 对比，它的响应速度是极快的。

当更改列表/对象中属性的值时 **（非长度变化）**，不会触发列表循环，会直接去更新 **列表项** 的渲染节点。
