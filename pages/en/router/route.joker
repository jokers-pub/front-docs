<template>
    <div ref="container" class="joker-demo-container">
        <h2>Routing Information</h2>
        <p>
            This section primarily introduces how we obtain current routing information and the attributes contained within the routing information.
        </p>
        <h3>How to Use</h3>
        <p>
            We can retrieve the
            <strong>route</strong>
            object either during Joker Router initialization or via the
            <code>router</code>
            instance. This object represents our current routing information.
        </p>
        <pre><code class="language-ts">import { router } from &quot;@joker.front/router&quot;;

// Get the route object
router.route;
</code></pre>
        <h3>How to Monitor Route Changes</h3>
        <p>
            It’s important to note that the
            <code>router.route</code>
            object is a
            <strong>Shallow Observer data shallow proxy</strong>
            object. If you're unfamiliar with this feature, you can learn more in the
            <a href="/base/observer" target="_blank">Data Proxy</a>
            section.
        </p>
        <p>
            Since this object is reactive, we can detect route changes by
            <a href="/base/watcher" target="_blank">subscribing</a>
            to data updates.
        </p>
        <pre><code class="language-ts">new Watcher(
    () =&gt; router.route.value,
    () =&gt; {
        // Route changed
    }
);
</code></pre>
        <h3>Attribute List</h3>
        <p>
            Below is the data structure of the
            <code>route</code>
            object:
        </p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Attribute</th>
                    <th>Description</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>name</td>
                    <td>
                        The
                        <code>name</code>
                        value of a named route
                    </td>
                    <td>string / symbol</td>
                </tr>
                <tr>
                    <td>path</td>
                    <td>
                        The final accessed path (corresponding to the
                        <code>path</code>
                        in router configuration, excluding dynamic parameters)
                    </td>
                    <td>string</td>
                </tr>
                <tr>
                    <td>fullPath</td>
                    <td>The complete accessed path</td>
                    <td>string</td>
                </tr>
                <tr>
                    <td>query</td>
                    <td>URL query parameters</td>
                    <td>object</td>
                </tr>
                <tr>
                    <td>hash</td>
                    <td>Browser hash value</td>
                    <td>string</td>
                </tr>
                <tr>
                    <td>params</td>
                    <td>Page parameters</td>
                    <td>object</td>
                </tr>
                <tr>
                    <td>meta</td>
                    <td>Route metadata, used to store static values associated with the current route</td>
                    <td>object</td>
                </tr>
                <tr>
                    <td>redirectedFrom</td>
                    <td>Redirect source</td>
                    <td>RouteLocationBase/undefined</td>
                </tr>
                <tr>
                    <td>matched</td>
                    <td>The collection of matched route records for the current path</td>
                    <td>RouteRecord[]</td>
                </tr>
            </tbody>
        </table>
        <h3>matched [Matched Route Collection]</h3>
        <p>
            To fully understand the
            <code>matched</code>
            concept, let’s delve into its underlying principles. The following example will explain how
            <code>matched</code>
            works in detail.
        </p>
        <p>Consider a scenario with nested routes:</p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/base&quot;,
            component: ChildrenLayout,
            childrens: [
                { path: &quot;page1&quot;, component: () =&gt; import(&quot;./page1.joker&quot;) },
                { path: &quot;page2&quot;, component: () =&gt; import(&quot;./page2.joker&quot;) }
            ]
        }
    ]
});
</code></pre>
        <p>
            When accessing
            <code>/base/page1</code>
            , the
            <code>matched</code>
            array of the current route will contain two entries:
        </p>
        <pre><code class="language-ts">[
    {
        path: &quot;/base&quot;
        // ...
    },
    {
        path: &quot;page1&quot;
        // ...
    }
];
</code></pre>
        <p>
            This example demonstrates that
            <code>matched</code>
            stores all matched route records in hierarchical order.
        </p>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>