<template>
    <div ref="container" class="joker-demo-container">
        <h2>Route State Preservation [keepalive]</h2>
        <p>This chapter introduces what route state preservation is and how to use it.</p>
        <h3>What is Route State Preservation</h3>
        <p>
            When developing Single Page Applications (SPAs), we often encounter scenarios where users navigate from a list page to a detail page. Upon returning to the list page, we want to maintain the list's query conditions, pagination state, and other interactive features without re-rendering the entire list page. In such cases, we need to enable route state preservation for a specific page to prevent it from being completely destroyed upon leaving.
        </p>
        <h3>How to Use</h3>
        <p>
            We can configure the
            <code>keepalive</code>
            property of a route during registration by setting it to
            <code>true</code>
            or
            <code>'once'</code>
            to achieve route state preservation. Different configuration types have the following meanings (
            <strong>default: undefined</strong>
            ):
        </p>
        <ul>
            <li>
                <p>
                    <code>true</code>
                    : Always keeps the component alive. The cache can be destroyed and refreshed using the
                    <strong>refresh</strong>
                    property during
                    <a href="/router/change" target="_blank">navigation</a>
                    .
                </p>
            </li>
            <li>
                <p>
                    <code>'once'</code>
                    : The component is cached only once. The cached version is rendered the first time, but it will be treated as a fresh component from the second rendering onward. This is typically suitable for routes that are
                    <em>frequently accessed but infrequently updated</em>
                    .
                </p>
            </li>
            <li>
                <p>
                    <code>false/undefined</code>
                    : No state preservation is applied.
                </p>
            </li>
        </ul>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/product/index&quot;,
            component: IndexComponent,
            keepalive: true
        }
    ]
});
</code></pre>
        <h3>How to Clear the State</h3>
        <p>
            When we need to refresh a page with preserved state, we can use the
            <strong>refresh: true</strong>
            option in the
            <code>push</code>
            method to clear the target route's cached state.
        </p>
        <pre><code class="language-ts">push({
    path: &quot;#product/list&quot;,
    refresh: true
});
</code></pre>
        <blockquote>
            <p>
                Alternatively, instead of clearing the cache, you can use the two
                <a href="/base/component-lifecycle" target="_blank">lifecycle functions</a>
                <code>sleeped</code>
                and
                <code>wakeup</code>
                to implement data refresh operations within the component. Using
                <code>refresh</code>
                destroys and recreates the cached component instance.
            </p>
        </blockquote>
        <h3>Use Cases for 'once'</h3>
        <p>
            When
            <code>keepalive</code>
            is set to
            <strong>once</strong>
            , the page is cached only once. Here are scenarios where
            <code>once</code>
            can efficiently implement state preservation:
        </p>
        <ol>
            <li>
                <strong>Frequent access with infrequent updates</strong>
                : Use
                <code>once</code>
                to reduce rendering overhead for pages that are frequently visited but rarely updated.
            </li>
            <li>
                <strong>Single navigation chain</strong>
                : If the next-level route can only return to the current page (i.e., the navigation chain is linear),
                <code>once</code>
                can preserve state effectively.
            </li>
        </ol>
        <p>
            For such linear navigation patterns, using
            <code>once</code>
            eliminates the need for manual
            <code>refresh</code>
            during navigation, as the page no longer exists in the cache upon subsequent visits in the forward direction.
        </p>
        <p>
            Of course, you can explore and extend this caching strategy for more advanced use cases tailored to your needs.
        </p>
        <h3>Why Not Clear Cache Based on Navigation Direction?</h3>
        <p>
            Some may wonder why the cache cannot be cleared dynamically based on the navigation direction. In reality, browsers do not expose user navigation history during routing, making it impossible to determine whether a navigation is a back action or a forward transition to a new page.
        </p>
        <p>
            Though it is technically possible to track route changes using a global variable on the
            <code>window</code>
            object to infer navigation direction (e.g., by checking if the target route exists in the history), this approach is
            <strong>not recommended</strong>
            . The same route might represent either a backward navigation or a new business node in different contexts. For example, multiple pages could navigate to the same route but carry distinct business logic. Hence, custom history tracking for cache management introduces unnecessary complexity and unpredictability.
        </p>
        <p>
            For handling intricate routing scenarios, we recommend using the
            <strong>refresh</strong>
            property to explicitly control cache clearance, as it offers a more flexible and maintainable solution.
        </p>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>