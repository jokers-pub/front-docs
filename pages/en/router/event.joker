<template>
    <div ref="container" class="joker-demo-container">
        <h2>Route Events/States</h2>
        <p>
            This section mainly explores the events involved in the route navigation process and their applications. Leveraging these events can help us achieve various complex functions and optimizations.
        </p>
        <h3>isReady [Route Initialization Completed]</h3>
        <p>
            During route initialization,
            <code>Joker Core</code>
            initializes the view based on the current address and completes the first-time route loading.
        </p>
        <p>
            The
            <code>isReady</code>
            method not only indicates the completion of class instantiation but also represents the success or failure of a route loading. Only after the route has completed its first-time loading can we consider the page route to be ready.
        </p>
        <pre><code class="language-ts">import { Router } from &quot;@joker.front/router&quot;;

let appRouter = new Router({
    //...
});

appRouter.isReady().then(() =&gt; {
    //TODO:
});
</code></pre>
        <p>
            The
            <code>isReady</code>
            function returns a
            <strong>Promise</strong>
            object, allowing us to use the
            <code>then</code>
            method to listen for the successful first-time loading of the page route and the
            <code>catch</code>
            method to handle the failure of the first-time route loading.
        </p>
        <h3>errorCallbacks [Exception Handling]</h3>
        <p>
            You can use the
            <code>errorCallbacks</code>
            collection to listen for global route exceptions anywhere.
        </p>
        <pre><code class="language-ts">import { Router } from &quot;@joker.front/router&quot;;

let appRouter = new Router({
    //...
});

appRouter.errorCallbacks.add((err, to, from) =&gt; {
    //err: Error data
    //to: Target address
    //from: Source address
});
</code></pre>
        <p>
            In addition to the native error type, the
            <code>err</code>
            parameter may also be the internal
            <code>NavigationError</code>
            error type. This type includes the following properties:
        </p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Property Name</th>
                    <th>Description</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>type</td>
                    <td>Error type</td>
                    <td>NavigationErrorTypes (The enum information will be introduced later)</td>
                </tr>
                <tr>
                    <td>from</td>
                    <td>Source address</td>
                    <td>RouteLocation</td>
                </tr>
                <tr>
                    <td>to</td>
                    <td>Target address RouteLocation</td>
                    <td>RouteLocationRaw</td>
                </tr>
            </tbody>
        </table>
        <p>
            The
            <code>NavigationErrorTypes</code>
            enum includes:
        </p>
        <pre><code class="language-ts">export const enum NavigationErrorTypes {
    /**Redirect */
    REDIRECT,
    /**Aborted */
    ABORTED,
    /**Cancelled */
    CANCELLED,
    /**Multiple identical ones without a clear target */
    SAME,
    /** No route record was matched */
    MATCHER_NOT_FOUND = 4
}
</code></pre>
        <p>
            We can use the
            <code>isNavigationError</code>
            function provided by Joker Router to determine whether the current error object is of the
            <code>NavigationError</code>
            type.
        </p>
        <pre><code class="language-ts">import { isNavigationError } from &quot;@joker.front/router&quot;;

isNavigationError(err); //====&gt; true/false
</code></pre>
        <h3>beforeRouteCallbacks [Before Navigation]</h3>
        <p>
            We can add listener functions to
            <code>beforeRouteCallbacks</code>
            to implement aspect-oriented event listening before route navigation. In this way, we can perform some custom operations before route navigation, such as verifying user permissions and logging. This method allows us to control the route navigation process more flexibly and optimize the performance and user experience of the application.
        </p>
        <pre><code class="language-ts">import { Router } from &quot;@joker.front/router&quot;;

let appRouter = new Router({
    //...
});

appRouter.beforeRouteCallbacks.add((to, from, next) =&gt; {
    //to: Target address
    //from: Source address
    //next: Execute the next step
});
</code></pre>
        <p>
            For the event type
            <code>NavigationCallback</code>
            , please refer to the summary at the end of this chapter.
        </p>
        <h3>afterRouteCallbacks [After Navigation]</h3>
        <p>
            <code>afterRouteCallbacks</code>
            serves as a hook after navigation. Its usage is basically the same as that of
            <code>beforeRouteCallbacks</code>
            , except that it doesn't have the
            <strong>next</strong>
            /
            <strong>return</strong>
            mechanism to control the flow.
        </p>
        <pre><code class="language-ts">import { Router } from &quot;@joker.front/router&quot;;

let appRouter = new Router({
    //...
});

appRouter.beforeRouteCallbacks.add((to, from, err) =&gt; {
    //to: Target address
    //from: Source address
    //err: Error information. Refer to the error type description in errorCallbacks.
});
</code></pre>
        <blockquote>
            <p>
                It should be noted that
                <code>afterRouteCallbacks</code>
                , as an aspect-oriented event for route navigation, reflects the state of route switching, not the completion state of page loading. If you want to listen for the completion state of the
                <code>view container</code>
                loading, you can use the
                <strong>updated</strong>
                event in
                <a href="/router/router-view" target="_blank">router-view</a>
                to listen.
            </p>
        </blockquote>
        <h3>beforeEnter / beforeLeave</h3>
        <p>
            <code>beforeEnter</code>
            and
            <code>beforeLeave</code>
            are two lifecycle hooks in Joker Router. They are specific configuration properties for route records. Different from global event listening, these hooks allow us to manage aspect-oriented events at the route-level for specific route items. By configuring these lifecycle hooks for individual routes, we can control the entry and exit behaviors of routes more precisely.
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeEnter: (to, from, next) =&gt; {
                //TODO:
            }
        },
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeEnter: [
                (to, from) =&gt; {
                    //TODO：
                },
                (to, from) =&gt; {
                    //TODO：
                }
            ]
        }
    ]
});
</code></pre>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeLeave: (to, from, next) =&gt; {
                //TODO:
            }
        },
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeLeave: [
                (to, from) =&gt; {
                    //TODO：
                },
                (to, from) =&gt; {
                    //TODO：
                }
            ]
        }
    ]
});
</code></pre>
        <p>
            For the event type
            <code>NavigationCallback</code>
            , please refer to the summary at the end of this chapter.
        </p>
        <h3>NavigationCallback [Event Handling Type]</h3>
        <p>
            <code>NavigationCallback</code>
            is the event-handling type. Both global events and route-item lifecycle events follow the specifications of this type.
        </p>
        <pre><code class="language-ts">export type NavigationCallback = (
    to: RouteLocation,
    from: RouteLocation,
    next: NavigationNextCallback
) =&gt; Awaitable&lt;NavigationCallbackReturn&gt;;

export type NavigationCallbackReturn = Error | RouteLocationRaw | boolean | undefined | void;
</code></pre>
        <p>
            This class returns a
            <code>Promise</code>
            to achieve asynchronous processing.
        </p>
        <p>Parameter descriptions:</p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Description</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>to</td>
                    <td>Target address</td>
                    <td>RouteLocation</td>
                </tr>
                <tr>
                    <td>from</td>
                    <td>Source address</td>
                    <td>RouteLocation</td>
                </tr>
                <tr>
                    <td>next</td>
                    <td>Next operation, optional</td>
                    <td>Function</td>
                </tr>
            </tbody>
        </table>
        <p>
            Since we can register multiple aspect-oriented events to
            <code>beforeRouteCallbacks</code>
            , we must control their flow order and state. We can decide whether to proceed to the next step through the method return value or the
            <code>next</code>
            function. Let's take a detailed look:
        </p>
        <ol>
            <li>
                The first way is to decide the flow through the method return value. In this mode, the third parameter
                <code>next</code>
                doesn't need to be executed.
            </li>
        </ol>
        <pre><code class="language-ts">appRouter.beforeRouteCallbacks.add((to, from) =&gt; {
    //return false;
    //return new Error('Custom exception')
    //return 'Redirect address';
    //return {path:'Redirect address'}
    //return true/undefined/... Execute the next hook
});
</code></pre>
        <p>Return type descriptions:</p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>false</td>
                    <td>
                        Terminate the current navigation and trigger an error of type
                        <code>NavigationErrorTypes.ABORTED</code>
                    </td>
                </tr>
                <tr>
                    <td>Error</td>
                    <td>Terminate the current navigation and trigger an Error event</td>
                </tr>
                <tr>
                    <td>string</td>
                    <td>
                        Redirect to the specified address and trigger an error of type
                        <code>NavigationErrorTypes.REDIRECT</code>
                    </td>
                </tr>
                <tr>
                    <td>object</td>
                    <td>
                        Redirect to the specified address. The type conforms to
                        <a href="/router/change" target="_blank">RouteLocationRaw</a>
                        , and trigger an error of type
                        <code>NavigationErrorTypes.REDIRECT</code>
                    </td>
                </tr>
                <tr>
                    <td>Others</td>
                    <td>Execute the next hook</td>
                </tr>
            </tbody>
        </table>
        <ol start="2">
            <li>
                The second way is to decide whether to proceed through the
                <code>next</code>
                function.
            </li>
        </ol>
        <pre><code class="language-ts">appRouter.beforeRouteCallbacks.add((to, from, next) =&gt; {
    //next(false);
    //next(new Error('Custom exception'))
    //next('Redirect address');
    //next({path:'Redirect address'})
    //next(true/undefined/...) Execute the next hook
});
</code></pre>
        <p>
            It is recommended not to include other business code after the
            <code>next</code>
            method is executed to ensure the clarity and focus of the process.
        </p>
        <blockquote>
            <p>
                Through the above two ways of controlling the flow, we can see that
                <code>beforeRouteCallbacks</code>
                consists of multiple processing hooks. We will execute them one by one in order. Only after all hooks have been executed in sequence (without termination/redirection) will the current route navigation start.
            </p>
        </blockquote>
        <blockquote>
            <p>
                We allow the use of
                <code>async/await</code>
                syntax in the method to handle
                <code>Promise</code>
                and implement asynchronous business logic.
            </p>
        </blockquote>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>