<template>
    <div ref="container" class="joker-demo-container">
        <h2>Route Registration</h2>
        <p>
            This section primarily introduces how to register routes and understand the configuration rules for routes.
        </p>
        <p>
            Currently, two route registration methods are provided:
            <strong>Initialize Route Configuration</strong>
            and
            <strong>Dynamic Route Registration</strong>
            .
        </p>
        <h3>Initialize Route Configuration</h3>
        <p>
            We can configure all known route information for the entire project via the
            <code>routes</code>
            parameter during route initialization.
        </p>
        <pre><code class="language-ts">import { Router } from &quot;@joker.front/rourter&quot;;

// My Block Page
new Router({
    routes: [
        { path: &quot;/&quot;, redirect: &quot;/index&quot; },
        { path: &quot;/index&quot;, component: MyPage }
    ]
});
</code></pre>
        <h3>Dynamic Route Registration</h3>
        <p>
            We provide dynamic route registration methods, which allow us to dynamically manage route matching rules based on environment variables, dynamic variables, and other differences.
        </p>
        <pre><code class="language-ts">let appRouter = new Router({
    routes: [
        { path: &quot;/&quot;, redirect: &quot;/index&quot; },
        { path: &quot;/index&quot;, name:&quot;parent&quot; component: MyPage }
    ]
});

appRouter.addRoute({ path: &quot;/index&quot;, component: MyPage });

// Add child route to an existing route
appRouter.addRoute({ path: &quot;/children&quot;, component: MyPage },'parent')
</code></pre>
        <p>This method supports two parameters:</p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Parameter Name</th>
                    <th>Description</th>
                    <th>Parameter Type</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>route</td>
                    <td>The route item to be added</td>
                    <td>
                        <code>RouteRecordRaw</code>
                        , same as the initialization route configuration item
                    </td>
                </tr>
                <tr>
                    <td>parentRouteName</td>
                    <td>
                        The name of the parent route node. This requires the parent route to be a
                        <strong>named route</strong>
                        .
                        <strong>Optional</strong>
                        , if not configured, it will be treated as a first-level route.
                    </td>
                    <td>
                        <code>RouteRecordName(string/symbol)</code>
                    </td>
                </tr>
            </tbody>
        </table>
        <blockquote>
            <p>
                It's worth noting that dynamic route registration does not allow registering the landing page address. When the Joker Router
                <strong>initializes</strong>
                , it will load the current address/landing page by default. Therefore, when using this method to register routes,
                <strong>the registration must be completed before rendering the page</strong>
                .
            </p>
        </blockquote>
        <h3>Route Configuration Item [RouteRecordRaw]</h3>
        <p>
            The
            <strong>Route Configuration Item</strong>
            is a crucial data type to understand when registering routes with Joker Router. Whether initializing route items or dynamically registering routes, configuration must follow the
            <strong>RouteRecordRaw</strong>
            type.
        </p>
        <p>
            Below is the detailed attribute description for
            <strong>RouteRecordRaw</strong>
            :
        </p>
        <h3>path [Matching Rules]</h3>
        <p>
            The
            <code>path</code>
            attribute configures the matching rules for routes. The
            <code>path</code>
            offers rich configuration rules—it can be a static address like
            <code>/home/index</code>
            or a dynamic one like
            <code>/user/:id</code>
            . Let’s explore the matching rules in detail.
        </p>
        <p>
            The
            <code>path</code>
            attribute is of type
            <code>string</code>
            . We can configure a fixed static address to set route rules:
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;
        },
        {
            path: &quot;user/list&quot;
        }
    ]
});
</code></pre>
        <p>Additionally, we can configure dynamic matching rules using expressions:</p>
        <h4>Dynamic Parameters</h4>
        <p>
            We can set dynamic parameters using
            <code>:</code>
            . The keyword following
            <code>:</code>
            represents the name of the dynamic parameter.
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id&quot;
        }
    ]
});

/**
 * /user/abc   =&gt; true
 * /user/123   =&gt; true
 * /user       =&gt; false
 * /user/a/b   =&gt; false
 */
</code></pre>
        <p>
            When configured as above, routes like
            <code>/user/abc</code>
            or
            <code>/user/123</code>
            will be recognized as matching the current routing rule.
        </p>
        <p>
            Upon page load, content after
            <code>/user/</code>
            will be passed as a parameter to the
            <a href="/router/route" target="_blank">route information</a>
            under the
            <strong>id</strong>
            parameter.
        </p>
        <p>
            Accessing
            <code>/user</code>
            or
            <code>/user/abc/xxx</code>
            will
            <strong>not match</strong>
            the rule, as the
            <code>:</code>
            dynamic rule is configured only once and is non-repeatable.
        </p>
        <h4>Regex Constraints</h4>
        <p>
            We allow adding regex constraints to
            <code>:</code>
            dynamic parameters by configuring regex rules inside
            <code>()</code>
            , such as:
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id(\\d+)&quot;
        }
    ]
});

/**
 * /user/abc   =&gt;  false
 * /user/123   =&gt;  true
 */
</code></pre>
        <h4>Dynamic Concatenation</h4>
        <p>Dynamic parameters can be combined with static characters to form complex address matching rules, e.g.:</p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/:id([0-9]{2})hello&quot;
        }
    ]
});

/**
 * /home/12hello   =&gt;  true
 * /home/123hello  =&gt;  false
 */
</code></pre>
        <p>
            It’s important to note that even with
            <code>dynamic + static</code>
            concatenation in the expression, we will correctly parse the parameter variable during address conversion. For example,
            <code>/home/12hello</code>
            will parse the parameter as
            <strong>id='12'</strong>
            .
        </p>
        <h4>Optional Parameters</h4>
        <p>
            To make a parameter optional, append
            <code>?</code>
            . This signifies that the parameter is optional,
            <strong>not a regex constraint</strong>
            .
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id?&quot;
        }
    ]
});

/**
 * /user/abc   =&gt; true
 * /user       =&gt; true
 * /user/a/b   =&gt; false
 */
</code></pre>
        <p>
            For parameters with constraints, append
            <strong>?</strong>
            after
            <code>()</code>
            .
        </p>
        <pre><code class="language-ts">new Router({
    routers: [
        {
            path: &quot;/user/:id(\\d{2})?&quot;
        }
    ]
});

/**
 * /user/12   =&gt; true
 * /user      =&gt; true
 * /user/1    =&gt; false
 * /user/123  =&gt; false
 * /user/1/2  =&gt; false
 */
</code></pre>
        <h4>Repeatable</h4>
        <p>
            We can append
            <code>+</code>
            /
            <code>*</code>
            to dynamic parameters to indicate they can repeat.
            <code>+</code>
            means at least one repetition, while
            <code>*</code>
            allows optional repetition.
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id(\\d+)+&quot;
        }
    ]
});

/**
 * /user/1     =&gt; true
 * /user/1a    =&gt; false
 * /user/1/2/3 =&gt; true
 * /user       =&gt; false
 * /user/1/b   =&gt; false
 */
</code></pre>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id*&quot;
        }
    ]
});

/**
 * /user/abc   =&gt; true
 * /user       =&gt; true
 * /user/a/b   =&gt; true
 */
</code></pre>
        <p>Below is a complex static concatenation example:</p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user:id+&quot;
        }
    ]
});

/**
 * /userabc   =&gt; true  Parameter is abc
 * /user       =&gt; false
 */
</code></pre>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/:id(d+)+user&quot;
        }
    ]
});

/**
 * /123user   =&gt; true  Parameter is 123
 * /123+user  =&gt; false '+' is a variable modifier
 */
</code></pre>
        <h4>Repeatable + Optional [*]</h4>
        <p>
            When configuring the
            <code>*</code>
            modifier, it signifies the variable is optional and repeatable.
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id*&quot;
        }
    ]
});

/**
 * /user/abc   =&gt; true
 * /user       =&gt; true
 * /user/a/b   =&gt; true
 */
</code></pre>
        <h3>redirect [Redirection]</h3>
        <p>
            We can configure the
            <code>redirect</code>
            property to implement route redirection.
        </p>
        <pre><code class="language-js">new Router({
    routes: [
        {
            path: &quot;/&quot;,
            redirect: &quot;/home/index&quot;
        }
    ]
});
</code></pre>
        <p>
            The above code means that when no address is specified, it redirects to
            <code>/home/index</code>
            .
            <br />
            <strong>redirect</strong>
            supports not only string values but also method-based redirection and richer configurations.
        </p>
        <p>More configurations:</p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/&quot;,
            redirect: {
                name: &quot;NamedRoute&quot;,
                params: { value: &quot;1&quot; }
            }
        },
        {
            path: &quot;/&quot;,
            redirect: {
                hash: &quot;/home/index&quot;,
                query: { value: &quot;1&quot; }
            }
        },
        {
            path: &quot;/&quot;,
            redirect: {
                path: &quot;/home/index&quot;
            }
        }
    ]
});
</code></pre>
        <p>
            Custom method that receives the current route information and returns a new route. The return type follows the format provided in the
            <strong>richer configurations</strong>
            above:
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/&quot;,
            redirect: (to: RouteLocationBase) =&gt; {
                return {
                    name: &quot;NamedRoute&quot;,
                    params: { value: &quot;1&quot; }
                };
            }
        }
    ]
});
</code></pre>
        <h3>name [Named Routes]</h3>
        <p>
            We can add a
            <code>name</code>
            property to a route configuration to name it. Named routes can be quickly referenced during navigation, route additions, etc., using the
            <strong>name</strong>
            .
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            name: &quot;home&quot;
        }
    ]
});
</code></pre>
        <h3>alias [Route Alias]</h3>
        <p>
            <code>alias</code>
            supplements the matching address and can be considered an alias for
            <code>path</code>
            . It can be a string or a string array, following the
            <code>path</code>
            type specification.
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            alias: &quot;/home&quot;
        },
        {
            path: &quot;/user/list&quot;,
            alias: [&quot;/user&quot;, &quot;/u/list&quot;, &quot;/user/all&quot;]
        }
    ]
});
</code></pre>
        <h3>meta [Route Metadata]</h3>
        <p>
            <code>meta</code>
            serves as the metadata property for routes, storing custom route data. Configured metadata can be accessed in route lifecycle events or route information for business operations.
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            meta: {
                param: &quot;v1&quot;
            }
        }
    ]
});
</code></pre>
        <p>Usage example:</p>
        <pre><code class="language-ts">let appRouter = new Router({
    //...
});

appRouter.beforeRouteCallbacks.add((to, from) =&gt; {
    if (to.meta.param === &quot;v1&quot;) {
        //TODO:
    }
});
</code></pre>
        <p>
            Alternatively, access it via the
            <code>router</code>
            object in components (see
            <a href="/router/route" target="_blank">Route Information</a>
            ).
        </p>
        <pre><code class="language-ts">import { router } from &quot;@joker.front/router&quot;;

if (router.route.value.meta.param === &quot;v1&quot;) {
    //TODO:
}
</code></pre>
        <h3>children [Child Routes]</h3>
        <p>
            The
            <code>children</code>
            property configures child routes for the current route, commonly referred to as
            <strong>nested routes</strong>
            .
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user&quot;,
            component: MyComponent,
            children: [
                { path: &quot;list&quot;, component: userListComponent },
                { path: &quot;info&quot;, component: userInfoComponent }
            ]
        }
    ]
});
</code></pre>
        <p>
            The above example creates a
            <code>/user</code>
            route with two child routes. If their
            <code>path</code>
            does not start with
            <code>/</code>
            , the child route matching rule is formed by concatenation (
            <strong>parent path/child path</strong>
            ):
        </p>
        <ul>
            <li>
                <code>/user/list</code>
            </li>
            <li>
                <code>/user/info</code>
            </li>
        </ul>
        <p>
            If the child route
            <code>path</code>
            starts with
            <strong>/</strong>
            , the parent
            <code>path</code>
            is ignored, e.g.:
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user&quot;,
            component: MyComponent,
            children: [
                { path: &quot;/user/list&quot;, component: userListComponent },
                { path: &quot;/user/info&quot;, component: userInfoComponent }
            ]
        }
    ]
});
</code></pre>
        <p>
            This will still resolve to
            <code>/user/list</code>
            and
            <code>/user/info</code>
            .
        </p>
        <p>
            <a href="/router/nested-routes" target="_blank">Nested Routes</a>
            will be covered in a dedicated section.
        </p>
        <h3>component/components [Route Components]</h3>
        <p>
            We can use
            <code>component</code>
            or
            <code>components</code>
            to configure the view components to be loaded for the current route. The difference is:
        </p>
        <ul>
            <li>
                <code>component</code>
                : The route loads a single component (one
                <code>&lt;router-view&gt;</code>
                tag in the layout).
            </li>
            <li>
                <code>components</code>
                : The route loads multiple components (multiple named
                <code>&lt;router-view&gt;</code>
                containers in the layout).
            </li>
        </ul>
        <p>
            For
            <code>&lt;router-view&gt;</code>
            , refer to
            <a href="/router/router-view" target="_blank">Dynamic Containers</a>
            .
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent
        },
        {
            path: &quot;/user/index&quot;,
            components: {
                top: userTopComponent,
                bottom: userBottomComponent
            }
        }
    ]
});
</code></pre>
        <p>
            Both
            <code>component</code>
            and
            <code>components</code>
            support lazy loading:
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: () =&gt; import(&quot;index.joker&quot;)
        },
        {
            path: &quot;/user/index&quot;,
            components: {
                top: userTopComponent,
                bottom: () =&gt; import(&quot;./user/bottom.joker&quot;)
            }
        }
    ]
});
</code></pre>
        <h3>props [Component Props]</h3>
        <p>
            The
            <code>props</code>
            property typically configures parameters for
            <code>component</code>
            or
            <code>components</code>
            . Parameters defined in
            <strong>props</strong>
            are passed as
            <code>props</code>
            during component initialization (see
            <a href="/base/component-property" target="_blank">Component Properties</a>
            ).
        </p>
        <p>
            Configuration depends on whether
            <code>component</code>
            or
            <code>components</code>
            is used. For a single
            <code>component</code>
            ,
            <code>props</code>
            follows the component's type constraints:
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            props: {
                p1: &quot;v1&quot;
            }
        }
    ]
});
</code></pre>
        <p>
            For
            <code>components</code>
            ,
            <code>props</code>
            must map to the
            <code>components</code>
            <strong>key</strong>
            to identify which component the props should be passed to:
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            components: {
                top: topComponent,
                bottom: bottomComponent
            },
            props: {
                top: {
                    p1: &quot;v1&quot;
                }
            }
        }
    ]
});
</code></pre>
        <p>
            In addition to static objects,
            <code>props</code>
            can be a function that dynamically generates props based on the rendering address. Both
            <code>component</code>
            and
            <code>components</code>
            support this:
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            props: (to) =&gt; {
                //TODO: Use `to` for business logic
                return {
                    message: &quot;I am a parameter&quot;
                };
            }
        }
    ]
});
</code></pre>
        <h3>beforeEnter [Route Entry Hook]</h3>
        <p>
            <code>beforeEnter</code>
            serves as the
            <strong>hook</strong>
            for the current route. It executes when the route matches but before rendering begins.
        </p>
        <p>
            Global Router events can also handle pre-rendering business logic. This
            <strong>hook</strong>
            provides a simple hook mechanism at the route configuration level.
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeEnter: (to, from, next) =&gt; {
                //TODO:
            }
        },
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeEnter: [
                (to, from) =&gt; {
                    //TODO：
                },
                (to, from) =&gt; {
                    //TODO：
                }
            ]
        }
    ]
});
</code></pre>
        <p>
            For
            <code>hook</code>
            function types, refer to
            <a href="/router/event" target="_blank">Component Events</a>
            , which adhere to the
            <strong>NavigationCallback</strong>
            type.
        </p>
        <h3>beforeLeave [Route Exit Hook]</h3>
        <p>
            <code>beforeLeave</code>
            serves as the
            <strong>hook</strong>
            for the current route. It executes when leaving the route.
        </p>
        <p>
            Global Router events can also handle this, but this
            <strong>hook</strong>
            provides a simple hook mechanism at the route configuration level.
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeLeave: (to, from, next) =&gt; {
                //TODO:
            }
        },
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeLeave: [
                (to, from) =&gt; {
                    //TODO：
                },
                (to, from) =&gt; {
                    //TODO：
                }
            ]
        }
    ]
});
</code></pre>
        <p>
            For
            <code>hook</code>
            function types, refer to
            <a href="/router/event" target="_blank">Component Events</a>
            , which adhere to the
            <strong>NavigationCallback</strong>
            type.
        </p>
        <h3>keepalive [State Retention]</h3>
        <p>
            Whether the loaded view component should retain its state when navigating away, allowing it to restore upon returning.
        </p>
        <p>
            For state retention, first review
            <a href="/base/component-lifecycle" target="_blank">Component Lifecycle</a>
            .
        </p>
        <p>
            The
            <code>keepalive</code>
            property supports various configurations (
            <strong>default: undefined</strong>
            ):
        </p>
        <ul>
            <li>
                <code>true</code>
                : Always retains state. Cache can be destroyed and refreshed using the
                <strong>refresh</strong>
                property during
                <a href="/router/change" target="_blank">navigation</a>
                .
            </li>
            <li>
                <code>'once'</code>
                : Retains state only once. The component renders from cache only the first time; subsequent renders treat it as a new component. Suitable for
                <strong>high-frequency access, low-frequency update</strong>
                routes.
            </li>
            <li>
                <code>false/undefined</code>
                : No state retention.
            </li>
        </ul>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/product/index&quot;,
            component: IndexComponent,
            keepalive: &quot;once&quot;
        }
    ]
});
</code></pre>
        <p>
            For more details, see
            <a href="/router/keepalive" target="_blank">State Retention</a>
            .
        </p>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>