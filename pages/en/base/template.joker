<template>
    <div ref="container" class="joker-demo-container">
        <h2>Joker Template Overview</h2>
        <p>
            This section introduces the basic usage of the
            <code>&lt;template&gt;</code>
            in Joker SFC (Single File Component). Joker employs an
            <code>HTML</code>
            -based template syntax combined with built-in dynamic directives to implement page layouts.
        </p>
        <p>
            At its core, Joker compiles templates into highly optimized
            <a href="/base/ast" target="_blank">AST</a>
            JavaScript code. During rendering, Joker establishes a relationship between virtual Nodes and actual rendered DOM nodes to ensure that updates to reactive data trigger minimal and immediate DOM updates. For details on virtual DOM and AST concepts, refer to the later chapter on
            <a href="/base/vnode" target="_blank">Virtual Nodes</a>
            .
        </p>
        <p>
            In Joker, all dynamic directives start with the
            <code>@</code>
            symbol. The framework provides a rich set of directive syntaxes, including dynamic text interpolation, conditional rendering, loops, and more, enabling developers to quickly build template layouts.
        </p>
        <h3>Dynamic Text</h3>
        <p>
            The most basic form of data binding is text interpolation, achieved using the
            <code>
                @("@property")
            </code>
            syntax:
        </p>
        <pre><code class="language-html">&lt;span&gt;@value&lt;/span&gt;  
</code></pre>
        <p>
            Here, the dynamic text references a property name corresponding to the current component instance's data. You can learn more about this in the
            <a href="/base/component-property" target="_blank">Component Properties</a>
            section.
        </p>
        <p>Beyond rendering a simple value, Joker supports complex expressions:</p>
        <pre><code class="language-html">&lt;span&gt;@(isTrue ? 'Content 1' : 'Content 2')&lt;/span&gt;  

&lt;span&gt;@(value + 1)&lt;/span&gt;  
</code></pre>
        <p>
            As shown above, wrapping expressions in
            <code>()</code>
            allows logic or computations within templates.
        </p>
        <p>
            In addition to accessing properties and using expressions, you can also read
            <code>getter properties</code>
            or display method return values. Let's explore this with a component example:
        </p>
        <pre><code class="language-html">&lt;template&gt;  
    &lt;span&gt;@name&lt;/span&gt;  
&lt;/template&gt;  
&lt;script&gt;  
    import { Component } from &quot;@joker.front/core&quot;;  
    export default class extends Component {  
        model = {  
            value: 0  
        };  
        get name() {  
            return this.model.value + 1;  
        }  
    }  
&lt;/script&gt;  
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Change the value of the model.&lt;/button&gt;
    &lt;/DemoRow&gt;
    &lt;p&gt;
        @name
    &lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        value: 0
    };

    get name() {
        return &quot;Zhang San&quot; + this.model.value;
    }

    handleClick() {
        this.model.value++;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                <strong>Note</strong>
                : The example above shows that if a
                <code>getter property</code>
                depends on reactive data, template updates will automatically reflect changes when the reactive data updates.
            </p>
        </blockquote>
        <p>
            However, in some cases, reactive data changes may not trigger template updates due to dependency tracking mechanism. For instance:
        </p>
        <pre><code class="language-ts">export default class extends Component {  
    model = {  
        value: 0  
    };  
    get name() {  
        if (false) {  
            // Reactive data is not accessed  
            return this.model.value + 1;  
        }  
        return 1;  
    }  
}  
</code></pre>
        <p>This design minimizes unnecessary reactive bindings to optimize rendering performance.</p>
        <p>Next, let's see an example of displaying a method return value:</p>
        <pre><code class="language-html">&lt;template&gt;  
    &lt;span&gt;@getName()&lt;/span&gt;  
&lt;/template&gt;  
&lt;script&gt;  
    import { Component } from &quot;@joker.front/core&quot;;  
    export default class extends Component {  
        model = {  
            value: 0  
        };  
        getName() {  
            return this.model.value + 1;  
        }  
    }  
&lt;/script&gt;  
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Change the value of the model.&lt;/button&gt;
    &lt;/DemoRow&gt;
    &lt;p&gt;
        @getName(&quot;Zhang San&quot;)
    &lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        value: 0
    };

    getName(preName: string) {
        return preName + this.model.value;
    }

    handleClick() {
        this.model.value++;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <p>
            The example demonstrates calling methods in templates, including passing arguments in the format
            <code>
                @("@methodName(param1, param2)")
            </code>
            . Remarkably, method calls also support reactive updates when underlying data changes.
        </p>
        <h4>Rendering Value Types (Advanced)</h4>
        <p>
            When using text interpolation (e.g.,
            <code>
                @("@text")
            </code>
            ), the runtime converts it to
            <strong>createText('text')</strong>
            . All non-string values are automatically coerced to strings via
            <code>String(value ?? '')</code>
            .
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;ul&gt;
        @for(let name in testValue) {
            &lt;li&gt;
                @name
                : @testValue[name]
            &lt;/li&gt;
        }
    &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    testValue = {
        objectValue: { name: &quot;1&quot; },
        arrayValue: [1, 2, 3],
        numberValue: 1,
        undefinedValue: undefined,
        nullValue: null,
        falseValue: false,
        trueValue: true
    };
}
&lt;/script&gt;


</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                By default,
                <code>
                    @property
                </code>
                is internally converted to
                <code>
                    @("@Text(property)")
                </code>
                for rendering. The
                <code>Text</code>
                directive is a built-in function (see the built-in directives list at the end).
            </p>
        </blockquote>
        <blockquote>
            <p>
                To render a literal
                <code>@</code>
                symbol followed by text (e.g.,
                <code>
                    @xxx
                </code>
                ), escape it as
                <code>
                    @("@&quot;@&quot;")xxx
                </code>
                .
            </p>
        </blockquote>
        <h3>HTML Rendering</h3>
        <p>
            To render a string as HTML, use the built-in
            <code>
                @Html("&lt;p&gt;&lt;/p&gt;")
            </code>
            function.
        </p>
        <blockquote>
            <p>
                By default, HTML fragments are rendered inside a
                <strong>Shadow DOM</strong>
                to isolate styles. Pass
                <code>false</code>
                as the second argument to disable Shadow DOM:
                <code>
                    @Html("&lt;p&gt;&lt;/p&gt;", false)
                </code>
                .
            </p>
        </blockquote>
        <pre><code class="language-html">&lt;p&gt;@Html('&lt;span&gt;123&lt;/span&gt;')&lt;/p&gt;  
&lt;p&gt;@Html(propertyName)&lt;/p&gt;  
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;p&gt;
        I'm：@Html(&quot;&lt;b&gt;Zhang San&lt;b&gt;&quot;)
    &lt;/p&gt;
    &lt;p&gt;
        I'm：@Html(userName)
    &lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    userName = `&lt;b&gt;Zhang San&lt;b&gt;`;
}
&lt;/script&gt;


</code></pre>
        </DemoContainer>
        <h3>Attributes</h3>
        <p>
            The
            <code>@</code>
            directive works in any context, including HTML attributes:
        </p>
        <pre><code class="language-html">&lt;p style=&quot;color:@fontColor&quot;&gt;Text content&lt;/p&gt;  
&lt;input value=&quot;@inputValue&quot; type=&quot;text&quot; /&gt;  
&lt;input value=&quot;I am @(age) years old&quot; type=&quot;text&quot; /&gt;  
</code></pre>
        <p>These examples show dynamic values applied to attributes, all supporting reactive updates.</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo5)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemorRow&gt;
        &lt;p style=&quot;color:@fontColor&quot;&gt;I'm the content&lt;/p&gt;
        &lt;div&gt;
            &lt;input value=&quot;@inputValue&quot; type=&quot;text&quot; /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input value=&quot;I'm already @(model.age) years old.&quot; type=&quot;text&quot; /&gt;
        &lt;/div&gt;
    &lt;/DemorRow&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Increase the age&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        age: 0
    };
    fontColor = &quot;var(--jk-color-success)&quot;;
    inputValue = &quot;I'm the input content&quot;;

    handleClick() {
        this.model.age++;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <h3>Component Props</h3>
        <p>
            Props enable communication between components. Beyond strings, props can accept any value type based on expressions:
        </p>
        <pre><code class="language-html">&lt;my-component  
    message=&quot;Static string&quot;  
    age=&quot;@(12)&quot;  
    user-list=&quot;@(['Alice', 'Bob'])&quot;  
    checked=&quot;@false&quot;  
    address-info=&quot;@({ city: 'Jinan' })&quot;  
    post-code=&quot;2500@(00)&quot;  
/&gt;  
</code></pre>
        <p>
            Complex expressions are supported via
            <code>
                @()
            </code>
            . Alternatively, props can reference component properties directly:
        </p>
        <pre><code class="language-html">&lt;template&gt;  
    &lt;my-component  
        age=&quot;@numberValue&quot;  
        user-list=&quot;@arrayValue&quot;  
        checked=&quot;@booleanValue&quot;  
        address-info=&quot;@getObjectValue&quot;  
    /&gt;  
&lt;/template&gt;  
&lt;script&gt;  
    import { Component } from &quot;@joker.front/core&quot;;  
    export default class extends Component {  
        numberValue = 12;  

        get arrayValue() {  
            return [&quot;Alice&quot;, &quot;Bob&quot;];  
        }  

        booleanValue = false;  

        getObjectValue() {  
            return { city: &quot;Jinan&quot; };  
        }  
    }  
&lt;/script&gt;  
</code></pre>
        <p>
            For
            <strong>boolean</strong>
            props, Joker optimizes shorthand syntax. An attribute without a value (or
            <code>=false</code>
            ) defaults to
            <code>true</code>
            :
        </p>
        <pre><code class="language-html">&lt;my-component checked /&gt;  

&lt;!-- Equivalent to --&gt;  
&lt;my-component checked=&quot;@true&quot; /&gt;  
</code></pre>
        <p>
            Additionally,
            <code>style</code>
            and
            <code>class</code>
            attributes support object/array formats:
        </p>
        <pre><code class="language-html">&lt;div  
    style=&quot;@({  
        width: '30px',  
        backgroundColor: 'red',  
        top: false,  
        height: undefined  
    })&quot;  
&gt;&lt;/div&gt;  
</code></pre>
        <p>
            The
            <code>style</code>
            object’s keys correspond to
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration" target="_blank">
                CSSStyleDeclaration
            </a>
            . Values set to
            <code>undefined/false</code>
            are omitted.
        </p>
        <p>
            For
            <code>class</code>
            :
        </p>
        <pre><code class="language-html">&lt;div class=&quot;@(['c1', 'c2'])&quot;&gt;&lt;/div&gt;  

&lt;div class=&quot;@({ 'c1': true, 'c2': false })&quot;&gt;&lt;/div&gt;  

&lt;div class=&quot;@([c1, c2, { c3: true, c4: false }])&quot;&gt;&lt;/div&gt;  
</code></pre>
        <p>
            Objects in
            <code>class</code>
            use keys as class names, with
            <code>true</code>
            /
            <code>false</code>
            toggling inclusion.
        </p>
        <blockquote>
            <p>
                This section covers passing props to components/elements. For receiving props, see
                <strong>props/propsOption</strong>
                in
                <a href="/base/component-property" target="_blank">Component Properties</a>
                .
            </p>
        </blockquote>
        <h3>Global Methods</h3>
        <p>Joker includes many built-in directives but also allows extending global methods for project efficiency:</p>
        <pre><code class="language-html">&lt;span&gt;Total: @Global.sum(1, 2)&lt;/span&gt;  
</code></pre>
        <pre><code class="language-ts">import { registerGlobalFunction } from &quot;@joker.front/core&quot;;  

registerGlobalFunction(&quot;sum&quot;, (arg1: number, arg2: number) =&gt; {  
    return arg1 + arg2;  
});  
</code></pre>
        <h3>Built-in Directives</h3>
        <p>Below is the full list of Joker’s built-in directives.</p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Directive</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Text</td>
                    <td>Inserts text content</td>
                </tr>
                <tr>
                    <td>Html</td>
                    <td>Renders HTML content</td>
                </tr>
                <tr>
                    <td>for</td>
                    <td>
                        <a href="/base/template-for" target="_blank">List rendering</a>
                    </td>
                </tr>
                <tr>
                    <td>if</td>
                    <td>
                        <a href="/base/template-if" target="_blank">Conditional rendering</a>
                    </td>
                </tr>
                <tr>
                    <td>section</td>
                    <td>
                        Marks a reusable content block (
                        <a href="/base/template-section" target="_blank">Block rendering</a>
                        )
                    </td>
                </tr>
                <tr>
                    <td>RenderSection</td>
                    <td>
                        Renders a marked block (
                        <a href="/base/template-section" target="_blank">Block rendering</a>
                        )
                    </td>
                </tr>
                <tr>
                    <td>Global</td>
                    <td>Calls globally registered methods</td>
                </tr>
            </tbody>
        </table>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo5 from "../../../examples/base/template/demo5.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/template/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/template/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/template/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/template/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo5,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>