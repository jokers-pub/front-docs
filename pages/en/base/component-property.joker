<template>
    <div ref="container" class="joker-demo-container">
        <h2>Component Attributes</h2>
        <p>
            Our component development is based on the powerful library
            <code>
                @("@joker.front/core")
            </code>
            . It provides developers with a series of tools and APIs, including lifecycle hook functions, API functions, and attributes, which can help us complete component development more efficiently and conveniently. In this chapter, we will delve into the composition of a component class, enabling you to understand how to utilize this library to create a component with rich functionality and superior performance.
        </p>
        <p>
            Joker provides some default attributes and attribute specification standards by default. This chapter mainly introduces these attributes to facilitate our better use of them during the development process.
        </p>
        <h3>Component Parameters (props / propsOption)</h3>
        <p>
            Parameters can be passed from the parent component to the child component. The child component uses TypeScript generics to specify the parameter types for the component, and
            <code>propsOption</code>
            can be used to set some constraints or default values for the parameters.
        </p>
        <pre><code class="language-ts">import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component&lt;{
    message: string;
    checked: boolean;
    money: number;
}&gt; {}
</code></pre>
        <p>
            As can be seen from the above code example, the current component will receive three parameters and specify the types of the three parameters.
        </p>
        <blockquote>
            <p>
                It should be noted that, in order to maintain maximum flexibility, Joker has weak constraints on component parameters. The defined generic types only exist as quick hints within the component and will not perform operations such as value conversion or non-null judgment.
            </p>
        </blockquote>
        <p>
            Of course, if your component has requirements for parameter constraints, default values, and type enforcement, we also provide
            <code>propsOption</code>
            for configuration.
        </p>
        <pre><code class="language-ts">import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component&lt;{
    message: string;
    age: number;
    money: number;
    zIndex: number;
}&gt; {
    propsOption = {
        money: {
            // Required parameter
            required: true,
            // Type
            type: [String, Number],
            // Validation
            validate(val: any) {
                let value = parseInt(val);
                if (isNaN(value)) {
                    console.error(&quot;money should be of the correct type&quot;);
                    return false;
                }
                return true;
            }
        },
        message: &quot;This is the default prompt&quot;,
        age: Boolean,
        zIndex: 1
    };
}
</code></pre>
        <p>
            From the above example, it can be seen that
            <code>propsOption</code>
            supports rich usage. Its rules are as follows:
        </p>
        <ol>
            <li>
                <p>
                    If it is
                    <code>String | ArrayConstructor | Number | Object | Function | Boolean</code>
                    or
                    <code>Array&lt;above types&gt;</code>
                    , it represents constraining the type of the value, and when retrieving the value, it will attempt to convert it according to the first default type. An error will be reported if the conversion fails.
                </p>
            </li>
            <li>
                <p>
                    If it is an object, and the object includes any of the properties
                    <code>type</code>
                    /
                    <code>required</code>
                    /
                    <code>default</code>
                    /
                    <code>validate</code>
                    , then the entire set of properties is used as parameter constraints.
                    Explanation of full-type parameters (all properties are optional):
                </p>
                <table class="mkd-table">
                    <thead>
                        <tr>
                            <th>Property Name</th>
                            <th>Description</th>
                            <th>Type</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>type</td>
                            <td>Value type</td>
                            <td>
                                <code>String / Array/ Number / Object / Function / Boolean</code>
                                or an array of the above types
                                <code>[above types]</code>
                            </td>
                        </tr>
                        <tr>
                            <td>required</td>
                            <td>Whether it is a required item</td>
                            <td>
                                <code>boolean</code>
                            </td>
                        </tr>
                        <tr>
                            <td>default</td>
                            <td>Default value</td>
                            <td>
                                <code>any</code>
                            </td>
                        </tr>
                        <tr>
                            <td>validate</td>
                            <td>Value validation method</td>
                            <td>
                                <code>(val:any)=&gt;boolean</code>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </li>
            <li>
                <p>
                    If it does not meet the above conditions, then the value is used as the default value of the parameter. When the parameter is
                    <strong>undefined</strong>
                    , this default value is returned.
                </p>
            </li>
        </ol>
        <p>
            From the above content, we can understand how to define the parameters of the current component and their constraints. Next, let's take a look at how to read the parameters.
        </p>
        <pre><code class="language-ts">let money = this.props.money;
</code></pre>
        <p>
            The parameters we defined can be obtained through the
            <code>props</code>
            object. It should be noted that this property is a read-only property and does not allow re-definition or setting of a new value.
        </p>
        <p>
            When handling parameter passing, we usually operate based on element tags. To maintain naming consistency and standardization, attribute names may use
            <code>camelCase</code>
            or be separated by
            <code>-</code>
            . To better accommodate multiple parameter naming standards, when reading parameters, we will adopt the following strategy: First, try to obtain the parameter directly using the original key name. If that fails, then we will try to convert each word to lowercase after capitalizing the first letter, split them, and connect them with
            <code>-</code>
            as the key, and then try to obtain the parameter again. This processing method ensures that we can flexibly adapt to different naming rules.
        </p>
        <p>For example:</p>
        <pre><code class="language-html">&lt;my-component success-message=&quot;This is the success prompt&quot; errorMessage=&quot;This is the error prompt&quot; /&gt;
</code></pre>
        <p>Then, in the component, the values can be retrieved in the following ways, all of which are allowed.</p>
        <pre><code class="language-ts">this.props.successMessage;
this.props[&quot;success-message&quot;];
this.props.errorMessage;
</code></pre>
        <p>
            Joker has further optimized for booleans internally. To avoid redundant operations like
            <code>
                checked=&quot;@("@true")&quot;
            </code>
            in the tag, when we encounter an attribute that is defined but has no configured value (note that it is not
            <code>undefined</code>
            , but there is no
            <code>=</code>
            ), it is treated as
            <code>true</code>
            by default. For example:
        </p>
        <pre><code class="language-html">&lt;my-component checked /&gt;
</code></pre>
        <p>
            For more template syntax, you can have an in-depth understanding by reading
            <a href="/base/template" target="_blank">Template</a>
            .
        </p>
        <p>
            The data in
            <code>props</code>
            is reactive data. When the external value changes, a synchronous notification will also be sent:
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;jk-input @input=&quot;handleInput&quot; placeholder=&quot;Please enter the content.&quot; /&gt;
    &lt;/DemoRow&gt;
    &lt;MyComponent message=&quot;@model.inputValue&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent
    };

    model = {
        inputValue: &quot;&quot;
    };

    handleInput(e: VNode.Event&lt;string&gt;) {
        this.model.inputValue = e.data;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <p>Code of the child component:</p>
        <pre><code class="language-html">&lt;template&gt;I'm the child component, the content you entered currently: @props.message&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;

    export default class extends Component&lt;{
        message: string
    }&gt; {}
&lt;/script&gt;
</code></pre>
        <h3>Reactive Data (model)</h3>
        <p>
            Joker internally provides a data hijacking method
            <a href="/base/observer" target="_blank">observer</a>
            . However, to facilitate developers to quickly define reactive data within components, we provide the
            <code>model</code>
            attribute by default. This attribute will be hijacked before the loading starts and provides the ability for data reactivity.
        </p>
        <pre><code class="language-ts">export default class extends Component {
    model = {
        value: &quot;&quot;
    };
}
</code></pre>
        <p>
            Of course, you can also use the
            <code>observer</code>
            method to define a reactive data.
        </p>
        <pre><code class="language-ts">export default class extends Component {
    list = observer({
        value: &quot;&quot;
    });

    created() {
        this.$watch(
            () =&gt; this.list,
            () =&gt; {
                // The value has changed
            }
        );
    }
}
</code></pre>
        <p>
            Since we are using the
            <code>TypeScript</code>
            standard, when the type of the
            <code>model</code>
            attribute is too complex, we can use the
            <code>as</code>
            method to specify the type for a certain attribute. For example:
        </p>
        <pre><code class="language-ts">export default class extends Component {
    model: {
        value?: { key: string; value: number };
    } = {
        value: undefined
    };
}
// Equivalent toðŸ‘‡ðŸ‘‡ðŸ‘‡ which is more convenient for complex attributes or multiple attributes
export default class extends Component {
    model = {
        value: undefined as { key: string; value: number } | undefined,
        message: &quot;&quot;
    };
}
</code></pre>
        <blockquote>
            <p>
                Note that we recommend storing only the reactive observable data in
                <code>model</code>
                . For temporary data, it can be directly configured as an attribute within the component class to reduce the overhead of reactive data.
            </p>
        </blockquote>
        <h3>Render Template (template)</h3>
        <p>
            In addition to using the
            <code>template</code>
            tag in the
            <code>SFC</code>
            mode to define the template, we can also define the template through the
            <code>template</code>
            attribute. The advantage of this is that we can create a more complex render template through JavaScript judgment.
        </p>
        <pre><code class="language-html">&lt;script&gt;
    import { Component, createElement, createText } from &quot;@joker.front/core&quot;;
    export default class extends Component {
        template = function () {
            let children = [];
            if (__DEV__) {
                children.push(createText(&quot;This is the content created by createText&quot;));
            }
            return [createElement(&quot;div&quot;, undefined, children)];
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;script&gt;
import { Component, createElement, createText } from &quot;@joker.front/core&quot;;
export default class extends Component {
    template = () =&gt; {
        let children = [];
        if (true) {
            children.push(createText(&quot;I'm the content created by createText.&quot;));
        }
        return [createElement(&quot;div&quot;, undefined, children)];
    };
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <h3>Private Components (component)</h3>
        <p>
            Configure the private components within the current component by configuring the
            <code>component</code>
            attribute. For the component registration mechanism, please refer to
            <a href="/base/component-register" target="_blank">Component Registration</a>
            .
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent /&gt;
    &lt;MyAsyncComponent /&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    import MyComponent from &quot;./children.joker&quot;;
    export default class extends Component {
        component = {
            MyComponent,
            MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent message=&quot;I'm the parameter.&quot; /&gt;
    &lt;MyAsyncComponent message=&quot;I'm the parameter.&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent,
        MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
    };
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            Component registration supports asynchronous operations. You can use the method
            <code>()=&gt;import('component.joker')</code>
            for asynchronous component references. Asynchronous reference components will not be loaded along with the initialization of the parent component, but will be loaded only when the component needs to be rendered. For example:
        </p>
        <pre><code class="language-html">&lt;template&gt;
    @if(false){
    &lt;MyAsyncComponent /&gt;
    }
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;

    export default class extends Component {
        component = {
            MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle the display state of the child component.&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.show) {
        &lt;MyAsyncComponent message=&quot;I'm the parameter.&quot; /&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;

export default class extends Component {
    components = {
        MyAsyncComponent: () =&gt; import(&quot;./async-children-import.joker&quot;)
    };
    model = {
        show: false
    };

    handleClick() {
        this.model.show = !this.model.show;
    }
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            From the above code and the console output (network), it can be seen that the asynchronous component will be loaded only when it is required to be loaded.
        </p>
        <h3>Root Node ($root / $rootVNode)</h3>
        <p>
            During rendering, every tag/component/directive exists in a tree-like structure, and components are no exception. We can obtain the mounting container/root node of a component by calling the two attributes
            <code>$root</code>
            and
            <code>$rootVNode</code>
            .
        </p>
        <p>
            So how do we distinguish between
            <code>$root</code>
            and
            <code>$rootVNode</code>
            ?
        </p>
        <ul>
            <li>
                <p>
                    <code>$root</code>
                    represents the mounting container of the current component. It is passed as a parameter and specified when the container is mounted ($mount). It can be an HTML
                    <code>Element</code>
                    or a
                    <code>VNode.Component</code>
                    .
                </p>
            </li>
            <li>
                <p>
                    <code>$rootVNode</code>
                    is the top-level node of the current component, and its type must be
                    <code>VNode.Root</code>
                    . Since our render template does not limit the number of top-level tags, it must be wrapped by a
                    <code>VNode.Root</code>
                    . Through this property, we can perform operations such as looking up nodes downward. The value of this property will be created only when the template is rendered, so the value of this property cannot be obtained within the
                    <code>created</code>
                    lifecycle.
                </p>
            </li>
        </ul>
        <p>
            For example, if we want to obtain all
            <code>Element</code>
            nodes of the current component
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;div&gt;1&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    //...
    // Get all element nodes
    this.$rootVNode?.find((n) =&gt; n instanceof VNode.Element);

    // Look up and find the nearest element node
    this.$rootVNode?.closest((n) =&gt; n instanceof VNode.Element);

    //...
&lt;/script&gt;
</code></pre>
        <p>
            For knowledge related to
            <code>VNode.Root</code>
            , you can click
            <a href="/base/vnode" target="_blank">Virtual Node</a>
            to learn more.
        </p>
        <h3>All Marked Nodes ($refs)</h3>
        <p>
            This property stores all marked nodes. This property is a read-only property. When nodes are added or destroyed, the value of this property will be synchronized accordingly (value synchronization, not reactive data. If you want to observe, it is recommended to use the
            <code>$watchNode</code>
            API).
        </p>
        <pre><code class="language-ts">let count = this.$refs.refName?.count;
</code></pre>
        <p>
            Of course, you can also call the
            <code>$getRef</code>
            and
            <code>$getRefs</code>
            methods to find marked nodes. These two methods can use TypeScript generic classes to specify the output type, which is more convenient for operation.
            <a href="/base/component-api" target="_blank">Component Built-in Methods</a>
        </p>
        <h3>Whether to Maintain State (isKeepAlive)</h3>
        <p>
            We can determine whether a component is required to maintain its state through this property. For components that are required to maintain their state, only the mounted element nodes will be destroyed during
            <code>$destroy</code>
            , rather than the entire component instance. For details, you can refer to
            <a href="/base/component-lifecycle" target="_blank">Component Lifecycle</a>
            .
        </p>
        <p>
            Call the component and configure
            <code>keep-alive</code>
            :
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent keep-alive /&gt;
&lt;/template&gt;
</code></pre>
        <p>
            In the child component, we can determine whether the current component rendering requires state maintenance through
            <strong>isKeepAlive</strong>
            .
        </p>
        <pre><code class="language-ts">export class extends Component {
    created() {
        if (this.isKeepAlive) {
            //TODO:...
        }
    }
}
</code></pre>
        <h3>Whether it is in Sleep State (isSleeped)</h3>
        <p>
            When a component is required to maintain its state, only the mounted element nodes will be destroyed during
            <code>$destroy</code>
            , rather than the entire component instance. For details, you can refer to
            <a href="/base/component-lifecycle" target="_blank">Component Lifecycle</a>
            .
            We can use this property to determine the current state of the component. For example:
        </p>
        <pre><code class="language-ts">export class extends Component {
    // Timed task trigger function
    testMethod() {
        // Ignore the timed execution when the component is asleep.
        if (this.isSleeped) return;

        MessageBox.alert(&quot;The timer has been triggered.&quot;);
    }
}
</code></pre>
        <h3>Render Sections ($sections)</h3>
        <p>
            This property is a read-only property representing the sections to be rendered passed into the current component. For usage, please refer to
            <a href="/base/template-section" target="_blank">Section Rendering</a>
            .
        </p>
        <pre><code class="language-ts">class extends Component {
    myFunction() {
        if (this.$sections.top) {
            // The top section template has been passed in
        } else {
            // The top section template has not been passed in
        }
    }
}
</code></pre>
        <p>
            The type of this property is an object type, where the
            <code>key</code>
            represents the section name, and the
            <code>value</code>
            represents the object data of the section to be rendered. Its detailed type is as follows (
            <code>SectionType</code>
            ):
        </p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Property Name</th>
                    <th>Description</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>asts</td>
                    <td>
                        AST tree, which can be understood by referring to
                        <a href="/base/ast" target="_blank">AST</a>
                    </td>
                    <td>
                        <code>AST.Node[]</code>
                    </td>
                </tr>
                <tr>
                    <td>ob</td>
                    <td>The data object (ob) required for rendering this template</td>
                    <td>
                        <code>Object</code>
                    </td>
                </tr>
                <tr>
                    <td>parser</td>
                    <td>The parser object where this template is rendered</td>
                    <td>
                        <code>ParserTemplate</code>
                    </td>
                </tr>
                <tr>
                    <td>params</td>
                    <td>
                        Parameters, which can be referred to in the section parameter chapter of
                        <a href="/base/template-section" target="_blank">Section Rendering</a>
                        . This property
                        <strong>does not represent the parameter value</strong>
                        but
                        <strong>the parameter name</strong>
                    </td>
                    <td>
                        <code>string[]</code>
                    </td>
                </tr>
            </tbody>
        </table>
        <blockquote>
            <p>
                This property is a read-only property. It is not recommended to modify the value of this property. The property value is generated internally by Core.
            </p>
        </blockquote>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/component-property/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/component-property/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/component-property/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/component-property/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>