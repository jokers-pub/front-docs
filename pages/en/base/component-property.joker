<template>
    <div ref="container" class="joker-demo-container">
        <h2>Component Properties</h2>
        <p>
            Our component development is based on the powerful library
            <code>
                @("@joker.front/core")
            </code>
            . It provides developers with a series of tools and APIs, including lifecycle hooks, API functions, and properties, which help us develop components more efficiently and conveniently. In this section, we will delve into the composition of a component class, allowing you to understand how to leverage this library to create feature-rich, high-performance components.
        </p>
        <p>
            Joker provides some default properties and property specification standards. This section mainly introduces these properties to help us better utilize them during development.
        </p>
        <h3>Component Props (props / propsOption)</h3>
        <p>
            In parent components, parameters can be passed to child components. Child components specify parameter types using TypeScript generics and can use
            <code>propsOption</code>
            to set constraints or default values for these parameters.
        </p>
        <pre><code class="language-ts">import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component&lt;{
    message: string;
    checked: boolean;
    money: number;
}&gt; {}
</code></pre>
        <p>
            The above code example shows that the current component will receive three parameters with their types specified.
        </p>
        <blockquote>
            <p>
                It is worth noting that Joker imposes weak constraints on component parameters to maintain maximum flexibility. The generic types defined serve only as quick hints within the component and do not perform value conversion, null checks, or other operations.
            </p>
        </blockquote>
        <p>
            However, if your component requires constraints, default values, or type enforcement for parameters, we also provide
            <code>propsOption</code>
            for configuration.
        </p>
        <pre><code class="language-ts">import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component&lt;{
    message: string;
    age: number;
    money: number;
    zIndex: number;
}&gt; {
    propsOption = {
        money: {
            //Required parameter
            required: true,
            //Type
            type: [String, Number],
            //Validation
            validate(val: any) {
                let value = parseInt(val);
                if (isNaN(value)) {
                    console.error(&quot;Please enter a valid type for 'money'&quot;);
                    return false;
                }
                return true;
            }
        },
        message: &quot;I am the default message&quot;,
        age: Boolean,
        zIndex: 1
    };
}
</code></pre>
        <p>
            The example above demonstrates the rich capabilities of
            <code>propsOption</code>
            . Its rules are as follows:
        </p>
        <ol>
            <li>
                <p>
                    If the value is
                    <code>String | ArrayConstructor | Number | Object | Function | Boolean</code>
                    or an array of these types, it enforces the parameter's type. When retrieving the value, it attempts conversion to the first default type and logs an error if the conversion fails.
                </p>
            </li>
            <li>
                <p>
                    If the value is an object containing any of the properties
                    <code>type</code>
                    ,
                    <code>required</code>
                    ,
                    <code>default</code>
                    , or
                    <code>validate</code>
                    , it treats all properties as parameter constraints.
                    <br />
                    Full property specifications (all optional):
                </p>
                <table class="mkd-table">
                    <thead>
                        <tr>
                            <th>Property</th>
                            <th>Description</th>
                            <th>Type</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>type</td>
                            <td>Value type</td>
                            <td>String / Array / Number / Object / Function / Boolean, or an array of these types</td>
                        </tr>
                        <tr>
                            <td>required</td>
                            <td>Whether the parameter is required</td>
                            <td>boolean</td>
                        </tr>
                        <tr>
                            <td>default</td>
                            <td>Default value</td>
                            <td>any</td>
                        </tr>
                        <tr>
                            <td>validate</td>
                            <td>Value validation method</td>
                            <td>(val: any) =&gt; boolean</td>
                        </tr>
                    </tbody>
                </table>
            </li>
            <li>
                <p>
                    If none of the above conditions are met, the value is treated as the default parameter value. When the parameter is
                    <strong>undefined</strong>
                    , this default value is returned.
                </p>
            </li>
        </ol>
        <p>
            The above content explains how to define a component's parameters and their constraints. Next, let's see how to read these parameters.
        </p>
        <pre><code class="language-ts">let money = this.props.money;
</code></pre>
        <p>
            The defined parameters can be accessed via the
            <code>props</code>
            object. Note that this property is read-only and cannot be redefined or assigned new values.
        </p>
        <p>
            When handling parameter passing, we typically operate based on element tags. To maintain naming consistency and standardization, property names may use
            <strong>camelCase</strong>
            or
            <strong>hyphen-separated</strong>
            formats. To better accommodate different parameter naming conventions, we adopt the following strategy when reading parameters: First, attempt to retrieve the parameter using the original key name. If unsuccessful, attempt to convert the
            <strong>first letter of each word to uppercase</strong>
            , then to lowercase, and concatenate them with
            <code>-</code>
            as the key. For example:
        </p>
        <pre><code class="language-html">&lt;my-component success-message=&quot;I am a success message&quot; errorMessage=&quot;I am an error message&quot; /&gt;
</code></pre>
        <p>In the component, these values can be accessed in the following ways, all of which are valid:</p>
        <pre><code class="language-ts">this.props.successMessage;
this.props[&quot;success-message&quot;];
this.props.errorMessage;
</code></pre>
        <p>
            Joker further optimizes boolean handling internally. To avoid redundant operations like
            <code>
                checked=&quot;@("@true")&quot;
            </code>
            in tags, when a property is defined but not assigned a value (note: not
            <strong>undefined</strong>
            , but without
            <code>=</code>
            ), it is treated as
            <strong>true</strong>
            . For example:
        </p>
        <pre><code class="language-html">&lt;my-component checked /&gt;
</code></pre>
        <p>
            For more template syntax, refer to the
            <a href="/base/template" target="_blank">Template</a>
            section.
        </p>
        <p>
            <code>props</code>
            data is reactive. When external values change, corresponding notifications are triggered:
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;jk-input @input=&quot;handleInput&quot; placeholder=&quot;Please enter the content.&quot; /&gt;
    &lt;/DemoRow&gt;
    &lt;MyComponent message=&quot;@model.inputValue&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent
    };

    model = {
        inputValue: &quot;&quot;
    };

    handleInput(e: VNode.Event&lt;string&gt;) {
        this.model.inputValue = e.data;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <p>Child component code:</p>
        <pre><code class="language-html">&lt;template&gt; I am the child component. Your current input: @props.message &lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;

    export default class extends Component&lt;{
        message: string
    }&gt; {}
&lt;/script&gt;
</code></pre>
        <h3>Reactive Data (model)</h3>
        <p>
            Joker provides the
            <a href="/base/observer" target="_blank">observer</a>
            method for data interception. However, to help developers quickly define reactive data within components, we offer the
            <code>model</code>
            property by default. This property is intercepted before mounting and provides reactive data capabilities.
        </p>
        <pre><code class="language-ts">export default class extends Component {
    model = {
        value: &quot;&quot;
    };
}
</code></pre>
        <p>
            Alternatively, you can use the
            <code>observer</code>
            method to define reactive data:
        </p>
        <pre><code class="language-ts">export default class extends Component {
    list = observer({
        value: &quot;&quot;
    });

    created() {
        this.$watch(
            () =&gt; this.list,
            () =&gt; {
                //Value changed
            }
        );
    }
}
</code></pre>
        <p>
            Since we use TypeScript standards, when the
            <code>model</code>
            property's type is complex, we can use
            <code>as</code>
            to specify the type for a property. For example:
        </p>
        <pre><code class="language-ts">export default class extends Component {
    model: {
        value?: { key: string; value: number };
    } = {
        value: undefined
    };
}
//Equivalent to ðŸ‘‡ðŸ‘‡ðŸ‘‡ More convenient for complex or multiple properties
export default class extends Component {
    model = {
        value: undefined as { key: string; value: number } | undefined,
        message: &quot;&quot;
    };
}
</code></pre>
        <blockquote>
            <p>
                Note: We recommend storing only reactive, observable data in
                <code>model</code>
                . Temporary data can be directly defined as properties within the component class to reduce reactive data overhead.
            </p>
        </blockquote>
        <h3>Rendering Template (template)</h3>
        <p>
            In addition to defining templates using the
            <code>template</code>
            tag in SFC mode, we can also use the
            <code>template</code>
            property to define templates. This allows us to create more complex rendering templates using JavaScript logic.
        </p>
        <pre><code class="language-html">&lt;script&gt;
    import { Component, createElement, createText } from &quot;@joker.front/core&quot;;
    export default class extends Component {
        template = function () {
            let children = [];
            if (__DEV__) {
                children.push(createText(&quot;Content created via createText&quot;));
            }
            return [createElement(&quot;div&quot;, undefined, children)];
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;script&gt;
import { Component, createElement, createText } from &quot;@joker.front/core&quot;;
export default class extends Component {
    template = () =&gt; {
        let children = [];
        if (true) {
            children.push(createText(&quot;I'm the content created by createText.&quot;));
        }
        return [createElement(&quot;div&quot;, undefined, children)];
    };
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <h3>Private Components (component)</h3>
        <p>
            Use the
            <code>component</code>
            property to configure private components within the current component. For component registration mechanisms, see
            <a href="/base/component-register" target="_blank">Component Registration</a>
            .
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent /&gt;
    &lt;MyAsyncComponent /&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    import MyComponent from &quot;./children.joker&quot;;
    export default class extends Component {
        component = {
            MyComponent,
            MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent message=&quot;I'm the parameter.&quot; /&gt;
    &lt;MyAsyncComponent message=&quot;I'm the parameter.&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent,
        MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
    };
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            Component registration supports asynchronous loading. Use
            <code>() =&gt; import('component.joker')</code>
            for asynchronous component references. Asynchronous components are not loaded during parent component initialization but are loaded only when the component needs to be rendered. For example:
        </p>
        <pre><code class="language-html">&lt;template&gt;
    @if(false){
    &lt;MyAsyncComponent /&gt;
    }
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;

    export default class extends Component {
        component = {
            MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle the display state of the child component.&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.show) {
        &lt;MyAsyncComponent message=&quot;I'm the parameter.&quot; /&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;

export default class extends Component {
    components = {
        MyAsyncComponent: () =&gt; import(&quot;./async-children-import.joker&quot;)
    };
    model = {
        show: false
    };

    handleClick() {
        this.model.show = !this.model.show;
    }
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            From the above code and console output (network), you can see that asynchronous components are loaded only when required.
        </p>
        <h3>Root Node ($root / $rootVNode)</h3>
        <p>
            During rendering, every tag/component/directive exists as a tree structure, and components are no exception. We can use
            <code>$root</code>
            and
            <code>$rootVNode</code>
            to access a component's container or root node.
        </p>
        <ul>
            <li>
                <p>
                    <code>$root</code>
                    : Represents the component's mounting container. It is specified when the container is mounted (
                    <code>$mount</code>
                    ) and can be an HTML
                    <code>Element</code>
                    or a
                    <code>VNode.Component</code>
                    .
                </p>
            </li>
            <li>
                <p>
                    <code>$rootVNode</code>
                    : Represents the component's top-level node, always of type
                    <code>VNode.Root</code>
                    . Since rendering templates can have multiple top-level tags, they must be wrapped by a
                    <code>VNode.Root</code>
                    . This property is created during template rendering and is not available in the
                    <code>created</code>
                    lifecycle hook.
                </p>
            </li>
        </ul>
        <p>
            For example, to retrieve all
            <code>Element</code>
            nodes in the current component:
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;div&gt;1&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    //...
    //Get all Element nodes
    this.$rootVNode?.find((n) =&gt; n instanceof VNode.Element);

    //Search upward for the nearest Element node
    this.$rootVNode?.closest((n) =&gt; n instanceof VNode.Element);

    //...
&lt;/script&gt;
</code></pre>
        <p>
            For more details on
            <code>VNode.Root</code>
            , refer to
            <a href="/base/vnode" target="_blank">Virtual Nodes</a>
            .
        </p>
        <h3>All Tagged Nodes ($refs)</h3>
        <p>
            This read-only property stores all tagged nodes. Its values synchronize when nodes are added or destroyed (value synchronization, not reactive data; use
            <code>$watchNode</code>
            API for observation).
        </p>
        <pre><code class="language-ts">let count = this.$refs.refName?.count;
</code></pre>
        <p>
            Alternatively, use
            <code>$getRef</code>
            and
            <code>$getRefs</code>
            methods to locate tagged nodes. These methods support TypeScript generics to specify output types for easier manipulation. Refer to
            <a href="/base/component-api" target="_blank">Component Built-in Methods</a>
            .
        </p>
        <h3>Is Keep Alive (isKeepAlive)</h3>
        <p>
            This property determines whether the component should maintain its state. Components marked for keep-alive will only destroy their mounted element nodes during
            <code>$destroy</code>
            , not the entire component instance. For details, see
            <a href="/base/component-lifecycle" target="_blank">Component Lifecycle</a>
            .
        </p>
        <p>
            Component call with
            <code>keep-alive</code>
            :
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent keep-alive /&gt;
&lt;/template&gt;
</code></pre>
        <p>
            In the child component, use
            <strong>isKeepAlive</strong>
            to determine whether the component should maintain its state during rendering.
        </p>
        <pre><code class="language-ts">export class extends Component {
    created() {
        if (this.isKeepAlive) {
            //TODO:...
        }
    }
}
</code></pre>
        <h3>Is Sleeping (isSleeped)</h3>
        <p>
            When a component is marked for keep-alive, only the mounted element nodes are destroyed during
            <code>$destroy</code>
            , not the entire component instance. For details, see
            <a href="/base/component-lifecycle" target="_blank">Component Lifecycle</a>
            .
            <br />
            Use this property to check the component's current state, for example:
        </p>
        <pre><code class="language-ts">export class extends Component {
    //Timer trigger function
    testMethod() {
        //Ignore execution if the component is sleeping.
        if (this.isSleeped) return;

        MessageBox.alert(&quot;Timer triggered.&quot;);
    }
}
</code></pre>
        <h3>Rendering Sections ($sections)</h3>
        <p>
            This read-only property represents the sections to be rendered within the component. For usage, see
            <a href="/base/template-section" target="_blank">Section Rendering</a>
            .
        </p>
        <pre><code class="language-ts">class extends Component {
    myFunction() {
        if (this.$sections.top) {
            //A top section template was passed
        } else {
            //No top section template was passed
        }
    }
}
</code></pre>
        <p>
            This property is of object type, where
            <code>key</code>
            represents the section name and
            <code>value</code>
            represents the section data object. Its detailed type (
            <code>SectionType</code>
            ) is as follows:
        </p>
        <h3>Listener ($listeners)</h3>
        <p>
            This property is
            <strong>read-only</strong>
            and represents all event listeners of the current component. If you want to determine whether a component has listened to a specific event, you can use this property for verification.
        </p>
        <pre><code class="language-ts">class extends Component {
    myFunction() {
        if (this.$listeners.click) {
            // The click event is listened to externally
        } else {
            // The click event is not listened to
        }
    }
}
</code></pre>
        <h3>Key Term Explanations</h3>
        <ul>
            <li>
                <strong>Read-only property</strong>
                : A property that can only be accessed (read) to get its value, and cannot be modified (written) directly in the code.
            </li>
            <li>
                <strong>Event listener</strong>
                : A function or method defined in the code that waits for a specific event (e.g., the
                <code>click</code>
                event here) to occur, and executes corresponding logic once the event is triggered.
            </li>
        </ul>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Description</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>asts</td>
                    <td>
                        AST tree. See
                        <a href="/base/ast" target="_blank">AST</a>
                        for details.
                    </td>
                    <td>AST.Node[]</td>
                </tr>
                <tr>
                    <td>ob</td>
                    <td>
                        The data object (
                        <code>ob</code>
                        ) required for rendering the template.
                    </td>
                    <td>Object</td>
                </tr>
                <tr>
                    <td>parser</td>
                    <td>
                        The parser object (
                        <code>ParserTemplate</code>
                        ) where the template is rendered.
                    </td>
                    <td>ParserTemplate</td>
                </tr>
                <tr>
                    <td>params</td>
                    <td>
                        Parameters. Refer to the section parameters in
                        <a href="/base/template-section" target="_blank">Section Rendering</a>
                        . This property refers to
                        <strong>parameter names</strong>
                        , not
                        <strong>values</strong>
                        .
                    </td>
                    <td>string[]</td>
                </tr>
            </tbody>
        </table>
        <blockquote>
            <p>
                This property is read-only. Modifying its values is not recommended, as they are generated internally by Core.
            </p>
        </blockquote>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/component-property/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/component-property/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/component-property/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/component-property/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>