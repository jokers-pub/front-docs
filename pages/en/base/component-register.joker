<template>
    <div ref="container" class="joker-demo-container">
        <h2>Component Registration</h2>
        <p>
            This section introduces how to register components, including the registration mechanisms for both private and global components.
        </p>
        <h3>Private Component Registration</h3>
        <p>
            Configure private components within the current component via the
            <code>component</code>
            property. For detailed registration mechanisms, refer to
            <a href="/base/component-register" target="_blank">Component Registration</a>
            .
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent /&gt;
    &lt;MyAsyncComponent /&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    import MyComponent from &quot;./children.joker&quot;;
    export default class extends Component {
        component = {
            MyComponent,
            MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent message=&quot;I'm a parameter.&quot; /&gt;
    &lt;MyAsyncComponent message=&quot;I'm a parameter.&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent,
        MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
    };
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            Component registration supports asynchronous loading. You can use
            <code>()=&gt;import('component.joker')</code>
            for asynchronous component references. Asynchronously loaded components will not be loaded during the parent component's initialization but only when the component needs to be rendered. For example:
        </p>
        <pre><code class="language-html">&lt;template&gt;
    @if(false){
    &lt;MyAsyncComponent /&gt;
    }
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;

    export default class extends Component {
        component = {
            MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle the display state of the child component.&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.show) {
        &lt;MyAsyncComponent message=&quot;I'm a parameter.&quot; /&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;

export default class extends Component {
    components = {
        MyAsyncComponent: () =&gt; import(&quot;./async-children-import.joker&quot;)
    };
    model = {
        show: false
    };

    handleClick() {
        this.model.show = !this.model.show;
    }
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            You can verify from the above code and console output (network) that the async component loads only when required.
        </p>
        <h3>Global Component Registration (registerGlobalComponent)</h3>
        <p>
            The Core library provides the
            <code>registerGlobalComponent</code>
            function for registering global components. Once registered, these components can be used across all components without repeated registrations.
        </p>
        <pre><code class="language-ts">import { registerGlobalComponent } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./components/my-component.joker&quot;;

// Single component registration
registerGlobalComponent(&quot;my-componet&quot;, MyComponent);

// Supports batch registration
registerGlobalComponent({
    &quot;my-componet&quot;: MyComponent,
    &quot;my-test-component&quot;: MyTestComponent,
    &quot;my-async-component&quot;: () =&gt; import(&quot;./components/async-component.joker&quot;)
    //...
});
</code></pre>
        <p>Example of global component usage:</p>
        <pre><code class="language-ts">import { registerGlobalComponent } from &quot;@joker.front/core&quot;;

// Register global components in main.ts (entry file)
registerGlobalComponent({
    DemoRow: DemoRow
});
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        I'm a text within the global component. This global component comes with a built-in padding property.
    &lt;/DemoRow&gt;
&lt;/template&gt;

</code></pre>
        </DemoContainer>
        <p>
            Like private components, global component registration also supports asynchronous component imports. Async components won't load during application startup but only when they are required for rendering.
        </p>
        <blockquote>
            <p>
                While the
                <strong>registerGlobalComponent</strong>
                function can be used anywhere, we recommend using it in the entry file for better clarity and maintainability.
            </p>
        </blockquote>
        <h3>Retrieving Global Components (getGlobalComponent)</h3>
        <p>
            The Core library provides the
            <strong>getGlobalComponent</strong>
            function to dynamically check and retrieve registered global components.
        </p>
        <p>Note that the return type can be one of three possibilities:</p>
        <ul>
            <li>
                <strong>undefined</strong>
                (not found)
            </li>
            <li>
                <strong>ComponentConstructor</strong>
                (component class awaiting initialization)
            </li>
            <li>
                <strong>ImportComponentConstructor</strong>
                (async component loader function)
            </li>
        </ul>
        <pre><code class="language-ts">getGlobalComponent(&quot;my-component&quot;);
</code></pre>
        <h3>Built-in Global Components (template)</h3>
        <p>
            We provide a virtual container node that acts purely as a wrapper to display nested content without rendering any element (Element) itself. This component can be used for grouping purposes. Example:
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;ul&gt;
        &lt;li&gt;Fixed Column 1&lt;/li&gt;
        &lt;li&gt;Fixed Column 2&lt;/li&gt;
        &lt;template ref=&quot;test&quot;&gt;
            &lt;li&gt;Column 3&lt;/li&gt;
            &lt;li&gt;Column 4&lt;/li&gt;
        &lt;/template&gt;
    &lt;/ul&gt;
&lt;/template&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;ul&gt;
            &lt;li&gt;I'm the fixed column 1&lt;/li&gt;
            &lt;li&gt;I'm the fixed column 2&lt;/li&gt;
            &lt;template ref=&quot;test&quot;&gt;
                &lt;li&gt;I'm the column 3&lt;/li&gt;
                &lt;li&gt;I'm the column 4&lt;/li&gt;
            &lt;/template&gt;
        &lt;/ul&gt;
    &lt;/DemoRow&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Get the number of non - fixed columns&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { VNode } from &quot;@joker.front/core&quot;;
import { Component } from &quot;@joker.front/core&quot;;
import { Message } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    handleClick() {
        let count = this.$getRef(&quot;test&quot;)?.find((n) =&gt; n instanceof VNode.Element).length || 0;

        Message(&quot;Got &quot; + count + &quot; non - fixed columns.&quot;);
    }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <h3>Built-in Global Component (dynamic component)</h3>
        <p>
            The built-in
            <code>&lt;component&gt;</code>
            is used for rendering dynamic components.
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo5)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleChangeComponet('Test1')&quot;&gt;Load Component 1&lt;/button&gt;
        &lt;button @click=&quot;handleChangeComponet('Test2')&quot;&gt;Load Component 2&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.name) {
        &lt;component name=&quot;@model.name&quot; message=&quot;I'm a parameter&quot; user-name=&quot;Zhang San&quot;&gt;
            &lt;span&gt;I'm the content&lt;/span&gt;
        &lt;/component&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { VNode } from &quot;@joker.front/core&quot;;
import { Component } from &quot;@joker.front/core&quot;;
import Test1 from &quot;./component-test1.joker&quot;;
import Test2 from &quot;./component-test2.joker&quot;;

export default class extends Component {
    model = {
        name: &quot;&quot;
    };
    components = {
        Test1,
        Test2
    };

    handleChangeComponet(e: VNode.Event, name: string) {
        this.model.name = name;
    }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
button {
    margin-right: 10px;
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <p>
            You can specify a component to render via its
            <code>name</code>
            , which can refer to either a private component or a global component. Changing the name will trigger a re-render with the new component.
        </p>
        <p>
            Use it as a dynamic component container. It handles props and events like regular components. Note that apart from
            <strong>keep-alive</strong>
            ,
            <strong>name</strong>
            ,
            <strong>transition-name</strong>
            , and
            <strong>ref</strong>
            , all other attributes are passed through to the actual rendered component. Event handling works similarlyâ€”we listen for
            <code>*</code>
            events on the rendered component (see
            <code>$on</code>
            API) and propagate them upwards without processing or intercepting.
        </p>
        <p>
            For advanced dynamic rendering scenarios, we also provide the
            <code>loadComponent</code>
            API:
        </p>
        <pre><code class="language-ts">import { Component, ComponentContainer } from &quot;@joker.front/core&quot;;

export default class extends Component {
    testFunction() {
        // Render component dynamically
        this.$getRef&lt;VNode.Component&lt;ComponentContainer&gt;&gt;(&quot;test&quot;)?.component.loadComponent(&quot;name&quot;);
    }
}
</code></pre>
        <p>
            As it is inherently a dynamic component with state preservation (keep-alive), we also provide the
            <code>removeCache</code>
            API to clear cached data for previously rendered components.
        </p>
        <pre><code class="language-ts">import { Component, ComponentContainer } from &quot;@joker.front/core&quot;;

export default class extends Component {
    testFunction() {
        // Clear component cache
        this.$getRef&lt;VNode.Component&lt;ComponentContainer&gt;&gt;(&quot;test&quot;)?.component.removeCache(&quot;name&quot;);
    }
}
</code></pre>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo5 from "../../../examples/base/component-register/demo5.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/component-register/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/component-register/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/component-register/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/component-register/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo5,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>