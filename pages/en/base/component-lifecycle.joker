<template>
    <div ref="container" class="joker-demo-container">
        <h2>Component Lifecycle</h2>
        <p>
            In Joker, the component lifecycle begins when a component class is instantiated and its view along with child views are rendered. This lifecycle involves continuous change detection, where Joker monitors data-bound property changes and updates the views and component instances when necessary. The lifecycle ends when the component instance is destroyed and its rendered template is removed from the DOM. During Joker’s execution, directives also undergo a similar lifecycle during the creation, update, and destruction of component instances.
        </p>
        <p>
            Your application can leverage lifecycle hook methods to respond to key events in the lifecycle of a component or directive. These methods can be used to initialize new instances, trigger change detection, handle updates, and perform cleanup operations before an instance is destroyed.
        </p>
        <h3>Responding to Lifecycle Events</h3>
        <p>
            You can respond to events in the lifecycle of a component or directive by implementing one or more lifecycle hook interfaces defined in the core library. These hook interfaces provide opportunities to operate on the component or directive instance at appropriate moments, such as during creation, update, or destruction.
        </p>
        <p>
            Each interface includes a unique hook method. For instance, the
            <code>create</code>
            hook method—when implemented in a component or directive class—will be called by Joker immediately after checking the input properties of the component or directive for the first time.
        </p>
        <pre><code class="language-ts">import { Component } from &quot;@joker.front/core&quot;;  

export default class extends Component {  
    created() {  
        // Triggered when the component is created  
    }  

    mounted() {  
        // Triggered after the component is rendered and mounted to the DOM  
    }  

    destroyed() {  
        // Triggered after the component is destroyed, serving as the final lifecycle hook  
    }  
}  
</code></pre>
        <p>You don’t need to implement all lifecycle hooks—only those you require.</p>
        <h3>The Order of the Lifecycle</h3>
        <p>
            When your application creates a component instance by calling its constructor, Joker invokes the implemented hook methods according to the phases of the instance’s lifecycle.
        </p>
        <p>
            Below is a diagram of the instance lifecycle. You don’t need to fully understand every aspect of it now, but it will serve as a useful reference later.
        </p>
        <p>
            <img src="/base/component-life.png" alt="Component Lifecycle" />
        </p>
        <h3>Lifecycle for Components with State Persistence</h3>
        <p>
            In Joker’s default architecture, the mounting and unmounting of a component are one-time events with no state persistence. To address scenarios requiring state preservation, Joker provides the
            <code>keep-alive</code>
            attribute. This allows a component to
            <strong>destroy only its DOM nodes</strong>
            during the
            <code>destroy</code>
            call, while keeping the component instance alive. When the component is mounted again, it reuses the
            <strong>surviving instance</strong>
            to
            <strong>re-render</strong>
            the DOM, thereby maintaining the component’s state.
        </p>
        <p>With the above feature, the lifecycle for such state-persistent components is as follows:</p>
        <p>
            <img src="/base/keepalive-life.png" alt="Component Lifecycle" />
        </p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Hook Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>created</td>
                    <td>Triggered when the component is created</td>
                </tr>
                <tr>
                    <td>mounted</td>
                    <td>Triggered after the component renders and mounts to the DOM</td>
                </tr>
                <tr>
                    <td>beforeDestroy</td>
                    <td>Triggered before the component is destroyed</td>
                </tr>
                <tr>
                    <td>destroyed</td>
                    <td>Triggered after the component is destroyed, serving as the final lifecycle hook</td>
                </tr>
                <tr>
                    <td>sleeped</td>
                    <td>Hook triggered when the component is put to sleep</td>
                </tr>
                <tr>
                    <td>weakup</td>
                    <td>Hook triggered when the component is awakened</td>
                </tr>
            </tbody>
        </table>
        <p>
            At this point, you may have many questions. Don’t worry—proceed to the next chapter for further learning. A comprehensive tutorial will fully guide you through Joker’s features.
        </p>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>