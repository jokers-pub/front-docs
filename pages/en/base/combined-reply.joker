<template>
    <div ref="container" class="joker-demo-container">
        <h2>Combined Reply</h2>
        <p>This chapter mainly introduces what combined reply is and its use cases.</p>
        <p>
            Before reading this chapter, please familiarize yourself with
            <a href="/base/render" target="_blank">Template Rendering</a>
            .
        </p>
        <h3>Why Use Combined Reply</h3>
        <p>
            Joker Core's real-time rendering mechanism ensures synchronized updates between the UI and data state. Any changes in data are immediately reflected in the associated templates. This mechanism works well when handling events such as user interactions, where users expect real-time feedback. However, in certain scenarios—such as frequent internal data updates within a method—this immediacy can lead to performance issues, as every small data change triggers a rendering update.
        </p>
        <p>
            To address this problem, we introduce the
            <strong>Combined Reply mechanism</strong>
            . This approach allows all data updates within a logical processing unit (e.g., a method) to be collected first, optimized (e.g., deduplicated and merged), and rendered only once at the appropriate time. As a result, unnecessary intermediate rendering updates caused by frequent minor data changes are avoided, significantly improving performance. In short, this method centralizes updates at the right moment, achieving efficient page rendering with minimal performance cost.
        </p>
        <h3>How to Use</h3>
        <p>The usage is very simple:</p>
        <pre><code class="language-ts">import { combinedReply } from &quot;@joker.front/core&quot;;

combinedReply(() =&gt; {
    // Write your code here
});
</code></pre>
        <p>
            Let’s compare the difference with and without
            <code>combinedReply</code>
            using a
            <strong>change counter</strong>
            example:
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;p&gt;Click the button, and the value will be changed 5 times.&lt;/p&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Change Value ( @model.value )&lt;/button&gt;
    &lt;/DemoRow&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        value: 0
    };

    changeCount = 0;

    created() {
        this.$watch(
            () =&gt; this.model.value,
            () =&gt; {
                this.changeCount++;
            }
        );
    }

    handleClick() {
        this.model.value++;
        this.model.value++;
        this.model.value++;
        this.model.value++;
        this.model.value++;

        MessageBox.alert(`It is detected that there have been ${this.changeCount} changes`);

        //重置计数器
        this.changeCount = 0;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <p>
            Now, observe the effect after applying
            <code>combinedReply</code>
            :
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;p&gt;Click the button, and the value will be changed 5 times.&lt;/p&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Change Value ( @model.value )&lt;/button&gt;
    &lt;/DemoRow&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component, combinedReply } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        value: 0
    };

    changeCount = 0;

    created() {
        this.$watch(
            () =&gt; this.model.value,
            () =&gt; {
                this.changeCount++;
            }
        );
    }

    handleClick() {
        combinedReply(() =&gt; {
            this.model.value++;
            this.model.value++;
            this.model.value++;
            this.model.value++;
            this.model.value++;
        });

        MessageBox.alert(`It is detected that there have been ${this.changeCount} changes`);
        //重置计数器
        this.changeCount = 0;
    }
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            The examples above show that while the page ultimately updates to the correct data, without `combinedReply**, the DOM is updated
            <strong>5 times</strong>
            in the background.
        </p>
        <p>
            Next, let’s examine another example demonstrating how
            <code>combinedReply</code>
            <strong>aggregates and optimizes subscriptions</strong>
            —changes that ultimately lead to no value updates are ignored.
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;p&gt;Click the button, and the value will be changed 5 times.&lt;/p&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Change Value ( @model.value )&lt;/button&gt;
    &lt;/DemoRow&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component, combinedReply } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        value: 0
    };

    changeCount = 0;

    created() {
        this.$watch(
            () =&gt; this.model.value,
            () =&gt; {
                this.changeCount++;
            }
        );
    }

    handleClick() {
        combinedReply(() =&gt; {
            this.model.value++;
            this.model.value++;
            this.model.value++;
            this.model.value++;
            this.model.value = 0;
        });

        MessageBox.alert(`It is detected that there have been ${this.changeCount} changes`);
        //重置计数器
        this.changeCount = 0;
    }
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            In this example, despite frequent modifications to
            <code>value</code>
            , since it remains
            <strong>0</strong>
            in the end, no data subscription updates are broadcasted.
        </p>
        <blockquote>
            <p>
                <strong>Note:</strong>
                Since
                <code>combinedReply</code>
                defers rendering until execution completes, you
                <strong>cannot immediately obtain the latest DOM</strong>
                in the code during processing.
            </p>
        </blockquote>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/combined-reply/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/combined-reply/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/combined-reply/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>