<template>
    <div ref="container" class="joker-demo-container">
        <h2>Rendering</h2>
        <p>
            This section aims to delve into the rendering architecture of
            <strong>Joker Core</strong>
            and its underlying technical principles.
        </p>
        <h3>Prerequisites</h3>
        <p>
            Please complete the
            <a href="/base/template" target="_blank">template</a>
            study first.
        </p>
        <p>
            Two key terms,
            <strong><code>AST</code></strong>
            and
            <strong><code>VNode</code></strong>
            , will be mentioned later. You can explore them in depth in the following chapters:
        </p>
        <ul>
            <li>
                <a href="/base/ast" target="_blank">AST</a>
                : Joker Abstract Syntax Tree.
            </li>
            <li>
                <a href="/base/vnode" target="_blank">VNode</a>
                : Virtual Node Tree, used to render the AST into structured data based on component state.
            </li>
        </ul>
        <h3>File Splitting</h3>
        <p>
            When developing component templates, Joker provides a standard
            <strong>HTML tag-based + dynamic directives</strong>
            development specification. These development-mode templates cannot run directly in browsers as browsers do not natively support Joker’s syntax. During runtime, the
            <code>Joker CLI</code>
            compiles and transpiles Joker files, splitting SFC (Single File Component) files into three executable files:
        </p>
        <ul>
            <li>
                <code>*.joker?type=script</code>
                – Component class
            </li>
            <li>
                <code>*.joker?type=template</code>
                – Component rendering template
            </li>
            <li>
                <code>*.joker?type=style</code>
                – Component styles
            </li>
        </ul>
        <p>
            These three files enable the execution of a component. In production environments, they are merged and minified, whereas in
            <strong>development (DEV)</strong>
            mode, they remain separate due to
            <code>Joker CLI</code>
            's
            <strong>ES Module-based</strong>
            loading mechanism, which compiles on demand. For details, refer to
            <a href="/cli" target="_blank">Joker CLI</a>
            .
        </p>
        <h3>Rendering Template</h3>
        <p>
            After understanding the file-splitting rules, this section focuses on the rendering mechanism of the
            <strong>Template</strong>
            .
        </p>
        <p>
            Since browsers do not recognize Joker’s syntax, the CLI compiles the
            <code>template</code>
            content into
            <strong>AST[]</strong>
            (Abstract Syntax Tree) during compilation. This AST is then parsed by the
            <strong><code>Parser</code></strong>
            class and the current component instance to generate
            <strong><code>VNode.Node[]</code></strong>
            (Virtual DOM Tree). Once the Virtual DOM Tree is built, the
            <strong><code>Render</code></strong>
            class performs the actual rendering.
        </p>
        <p>
            <img src="/base/render.png" alt="render" />
        </p>
        <ul>
            <li>
                <strong><code>AST.Node[]</code></strong>
                : Converts the template into data that Joker Core can process.
            </li>
            <li>
                <strong><code>VNode.Node[]</code></strong>
                : Stores structured rendering output data.
            </li>
        </ul>
        <blockquote>
            <p>
                The process of converting Joker files into
                <code>AST.Node[]</code>
                only occurs in the CLI during
                <strong>DEV</strong>
                or
                <strong>Prod</strong>
                builds. In production, the output consists solely of
                <strong>JS</strong>
                and
                <strong>CSS</strong>
                , eliminating the template-to-AST transformation.
            </p>
        </blockquote>
        <p>
            When
            <code>AST.Node[]</code>
            is compiled into
            <code>VNode.Node[]</code>
            , associations between nodes and reactive data are established. Whenever reactive data changes, the
            <strong>Parser</strong>
            updates the virtual nodes, which are then reflected in the DOM. Since the scope of updates is deterministic, this process is
            <strong>instantaneous</strong>
            and
            <strong>highly optimized</strong>
            .
        </p>
        <p>
            Because rendering is instantaneous, changes to reactive data immediately update the DOM, allowing real-time access to modified DOM nodes.
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Change the value and immediately get the DOM&lt;/button&gt;
    &lt;/DemoRow&gt;
    &lt;p ref=&quot;test&quot;&gt;
        The current value is: @model.value
    &lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        value: 0
    };

    handleClick() {
        this.model.value++;

        MessageBox.alert(this.$getRef(&quot;test&quot;)?.output.innerHTML);
    }
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <div class="warning">
            <p>
                If reactive data is modified multiple times in a tight loop, the DOM will also update repeatedly, incurring unnecessary performance overhead. In such cases, use
                <a href="/base/combined-reply" target="_blank">Batch Updates</a>
                to consolidate changes for a single render pass.
            </p>
        </div>
        <h3>Cross-Platform / Multi-Target Rendering (Advanced API)</h3>
        <p>
            The
            <strong>Render</strong>
            class is pluggable. By default, Joker Core includes
            <code>HTML Render</code>
            , which compiles
            <strong><code>VNode.Node[]</code></strong>
            into
            <strong>DOM Nodes</strong>
            .
        </p>
        <p>
            You can also
            <strong>customize the Renderer</strong>
            to target different platforms:
        </p>
        <pre><code class="language-ts">import { IContainer, Render } from &quot;@joker.front/core&quot;;

// Inject your custom implementation  
IContainer.bind(Render.IRENDERIOCTAGID, YourCustomRenderer);
</code></pre>
        <p>
            Your custom renderer must implement the
            <strong><code>Render.IRender</code></strong>
            interface:
        </p>
        <pre><code class="language-ts">export interface IRender {
    /**
     * Mounts the renderer to a root target.
     * @param root - The mounting root (type-agnostic for multi-platform compatibility)
     */
    mount(root: any): void;

    /**
     * Appends a node to the render tree.
     * @param node - NodeInfo
     */
    appendNode(node: VNode.Node): void;

    /**
     * Updates a node.
     * @param node - NodeInfo
     * @param propertyKey - Optional property to update
     */
    updateNode(node: VNode.Node, propertyKey?: string): void;

    /**
     * Removes a node.
     * @param node - The node to remove
     * @param reserveOutPut - Whether to retain the output
     */
    removeNode(node: VNode.Node, reserveOutPut?: boolean): void;

    /**
     * Destroys the renderer, unmounting DOM and releasing resources.
     */
    destroy(): void;

    /**
     * Triggers a transition (enter) on an element node.
     */
    elementToEnter(node: VNode.Element, name: string, type?: TransitionType, callBack?: Function): void;

    /**
     * Triggers a transition (leave) on an element node.
     */
    elementToLeave(node: VNode.Element, name: string, type?: TransitionType, callBack?: Function): void;

    /**
     * Dispatches a component event.
     * @returns `false` stops event propagation.
     */
    triggerEvent(node: VNode.Component, eventName: string, e: VNode.Event): void | false;
}
</code></pre>
        <p>
            Joker will continue expanding support for mainstream platforms, including
            <strong>native clients</strong>
            and
            <strong>mini-programs</strong>
            .
        </p>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/render/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>