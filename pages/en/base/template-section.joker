<template>
    <div ref="container" class="joker-demo-container">
        <h2>Block Rendering</h2>
        <p>This chapter introduces another form of parent-child component value passing.</p>
        <h3>What is Block Rendering</h3>
        <p>
            In addition to using
            <code>props</code>
            to pass parameters between parent and child components, we also provide another form of value passing. We can pass a piece of
            <strong>renderable content</strong>
            to the child component, and the child component decides when and where this template should be rendered.
        </p>
        <pre><code class="language-html">&lt;my-component&gt; I am a renderable content &lt;/my-component&gt;
</code></pre>
        <p>As shown above, we can specify the renderable template block content within the custom component tags.</p>
        <h3>How to Use</h3>
        <p>
            We can directly define the content of the
            <code>renderable block</code>
            within the component tags or use the
            <code>section</code>
            directive to define it. When there is only one renderable block and no rendering parameters, this directive can be omitted.
        </p>
        <pre><code class="language-xml">&lt;my-component&gt;
    &lt;p&gt;I am a renderable block template&lt;/p&gt;
&lt;/my-component&gt;

ðŸ‘‡ðŸ‘‡ðŸ‘‡Equivalent toðŸ‘‡ðŸ‘‡ðŸ‘‡
&lt;my-component&gt;
    @section(){
        &lt;p&gt;I am a renderable block template&lt;/p&gt;
    }
&lt;/my-component&gt;

ðŸ‘‡ðŸ‘‡ðŸ‘‡Equivalent toðŸ‘‡ðŸ‘‡ðŸ‘‡

&lt;my-component&gt;
    @section('default'){
        &lt;p&gt;I am a renderable block template&lt;/p&gt;
    }
&lt;/my-component&gt;
</code></pre>
        <p>
            If no block name is specified, it defaults to
            <strong>default</strong>
            . Of course, we can also define multiple renderable blocks:
        </p>
        <pre><code class="language-xml">&lt;my-component&gt;
    &lt;p&gt;I am a renderable default block template&lt;/p&gt;

    @section('top'){
        &lt;p&gt;I am a renderable Top block template&lt;/p&gt;
    }

    &lt;p&gt;I am a renderable default block template (Second line)&lt;/p&gt;

    @section('bottom'){
        &lt;p&gt;I am a renderable Bottom block template&lt;/p&gt;
    }
&lt;/my-component&gt;
</code></pre>
        <p>
            Blocks
            <strong>with names</strong>
            will be merged together to form the rendering content under that name, while blocks without specified names will all be merged into the
            <code>default</code>
            block.
        </p>
        <p>Letâ€™s look at the specific execution effect:</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent&gt;
        &lt;p&gt;I'm the default rendering block (1)&lt;/p&gt;
        @section(&quot;top&quot;) {
            &lt;p&gt;I'm the top rendering block&lt;/p&gt;
        }
        &lt;p&gt;I'm the default rendering block (2)&lt;/p&gt;
        @section(&quot;bottom&quot;) {
            &lt;p&gt;I'm the bottom rendering block&lt;/p&gt;
        }
    &lt;/MyComponent&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent
    };
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            Combining the above example, letâ€™s see how the child component renders these blocks. The following is the child component code:
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;p class=&quot;title&quot;&gt;Top block content:&lt;/p&gt;
    @RenderSection(&quot;top&quot;)
    &lt;p class=&quot;title&quot;&gt;Main content:&lt;/p&gt;
    @RenderSection()
    &lt;p class=&quot;title&quot;&gt;Bottom block content:&lt;/p&gt;
    @RenderSection(&quot;bottom&quot;)
&lt;/template&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
    p.title {
        font-size: 18px;
        font-weight: bold;
        margin-top: 10px;
    }
&lt;/style&gt;
</code></pre>
        <p>
            From the above code, we can see that the
            <code>RenderSection</code>
            API can be used to render the renderable block templates. Different block templates can be rendered by specifying the first parameter. If no block name is passed, the
            <strong>default</strong>
            block is rendered by default.
        </p>
        <h3>Block Operations</h3>
        <p>
            If you are developing a component, you might need to check whether a renderable template has been passed when the component is called. We can use the
            <code>$sections</code>
            in the
            <a href="/base/component-property" target="_blank">Component Properties</a>
            to determine this, for example:
        </p>
        <pre><code class="language-xml">&lt;div&gt;
    @if($sections.default){
        &lt;p&gt;@RenderSection()&lt;/p&gt;
    }
    else{
        &lt;p class=&quot;default&quot;&gt;Default message&lt;/p&gt;
    }
&lt;/div&gt;
</code></pre>
        <p>
            The above code ensures that if a renderable block template is passed, it will be rendered; otherwise, a default prompt message will be displayed.
        </p>
        <h3>Rendering Parameters</h3>
        <p>
            During the template rendering process, key data may need to be passed in certain scenarios, especially when using list components. Not only do we need to provide the rendering template for list items, but we also must provide the corresponding data for each item in the loop to ensure the rendering process can proceed smoothly.
        </p>
        <p>
            Our parameter passing is very intuitive. We divide it into two code segments to introduce the syntax rules: passing parameters and receiving parameters. First, passing parameters:
        </p>
        <pre><code class="language-xml">&lt;p&gt;
    @RenderSection('default','I am parameter 1',myVariable,...)
&lt;/p&gt;
</code></pre>
        <p>
            Itâ€™s worth noting that if parameters need to be passed, they start from the second parameter, which means we must specify the block name. Parameters can be static values or component properties.
        </p>
        <p>
            Next, letâ€™s look at how the parent component receives the parameters passed by the child component through block rendering:
        </p>
        <pre><code class="language-xml">&lt;my-component&gt;
@section('default',v1,v2,v3){
    &lt;p&gt;Parameter 1: @v1&lt;/p&gt;
    &lt;p&gt;Parameter 2: @v2&lt;/p&gt;
}
&lt;/my-component&gt;
</code></pre>
        <p>
            As seen in the above code, similar to passing parameters, the parameters also start from the second parameter, and the number and order of parameters correspond to the rules when passing parameters.
        </p>
        <p>Now, letâ€™s look at a running example:</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;p&gt;This is an example without passing a section:&lt;/p&gt;
        &lt;ListComponent list=&quot;@list&quot;&gt;&lt;/ListComponent&gt;
    &lt;/DemoRow&gt;
    &lt;DemoRow&gt;
        &lt;p&gt;This is an example of passing a section:&lt;/p&gt;
        &lt;ListComponent list=&quot;@list&quot;&gt;
            @section(&quot;default&quot;, userName) {
                &lt;span&gt;Name: &lt;b&gt;@userName&lt;/b&gt;&lt;/span&gt;
            }
        &lt;/ListComponent&gt;
    &lt;/DemoRow&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import ListComponent from &quot;./list-component.joker&quot;;

export default class extends Component {
    components = {
        ListComponent
    };

    list = [&quot;Zhang San&quot;, &quot;Li Si&quot;, &quot;Wang Wu&quot;];
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <p>
            The following is the example code for the
            <code>list-component</code>
            :
        </p>
        <pre><code class="language-xml">&lt;template&gt;
    &lt;ul&gt;
        @for(let item of props.list) {
            &lt;li&gt;
                @if($sections.default) {
                    @RenderSection(&quot;default&quot;, item)
                }
                else {
                    @item
                }
            &lt;/li&gt;
        }
    &lt;/ul&gt;
&lt;/template&gt;
</code></pre>
        <h3>Cross-Component Passing (Advanced)</h3>
        <p>
            In the development of some complex components, the renderable block template passed by the parent component does not necessarily have to be rendered by this component. It might continue to be passed down, and the deep-level component will execute the template rendering. In this case, we need
            <strong>cross-component passing</strong>
            of block templates.
        </p>
        <p>
            First, letâ€™s understand the
            <code>RenderSection</code>
            API. Its first parameter can be a
            <strong>string</strong>
            or
            <code>SectionType</code>
            (refer to
            <code>$sections</code>
            in
            <a href="/base/component-property" target="_blank">Component Properties</a>
            ). Since the block object can be passed, we can use this method to achieve cross-component block rendering:
        </p>
        <pre><code class="language-xml">&lt;template&gt;
    @RenderSection(topSection,'I am a parameter')
&lt;/template&gt;
</code></pre>
        <pre><code class="language-ts">class extends Component{
    get topSection(){
        //Search upward and get the slot to be rendered
        return this.$rootVNode.closest(...)?.component.$sections.top;

        //Can also be passed as a parameter
        return this.props.topSection;
    }
}
</code></pre>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/template-section/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/template-section/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>