<template>
    <div ref="container" class="joker-demo-container">
        <h2>Built-in Attributes</h2>
        <p>
            This section will focus on some highly efficient built-in functional attributes in the template. These attributes are designed to assist developers in quickly handling common development scenarios and improving development efficiency.
        </p>
        <h3>ref (Marker)</h3>
        <p>
            With these attributes, you can mark tags. Then, when using methods like
            <code>$getRef</code>
            in the
            <a href="#base/component-api">Component API</a>
            , you can quickly locate these marked tags.
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;div ref=&quot;myDiv&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    export default class extends Component {
        test() {
            this.$getRef(&quot;myDiv&quot;);
        }
    }
&lt;/script&gt;
</code></pre>
        <h3>keep-alive (State Retention)</h3>
        <p>
            Configure this property to retain the state of a
            <strong>component</strong>
            , allowing it to preserve its state during the rendering/destruction switch. This property is generally used in conjunction with the
            <code>if</code>
            directive.
        </p>
        <p>Let's understand this through the following example:</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.isShow) {
        &lt;template keep-alive&gt;
            &lt;input type=&quot;text&quot; placeholder=&quot;Enter content to observe the state&quot; /&gt;
        &lt;/template&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        isShow: true
    };

    handleClick() {
        this.model.isShow = !this.model.isShow;
    }
}
&lt;/script&gt;


</code></pre>
        </DemoContainer>
        <p>
            This property must act on
            <strong>component-type</strong>
            tags. Of course, you can also refer to the above example and use a virtual component to wrap it to achieve the function of state retention.
        </p>
        <p>
            Since the data is retained, when will the component instance be truly destroyed? Next, let's introduce the destruction mechanism of
            <code>keep-alive</code>
            :
        </p>
        <p>
            By learning the
            <code>$destroy</code>
            method in
            <a href="/base/component-api" target="_blank">Component Methods</a>
            , we know that it will only be destroyed when the parameter passed to this method is
            <code>true</code>
            .
        </p>
        <p>
            In the
            <code>if</code>
            judgment in our previous example, when the condition is not met and the content is destroyed, it is not specified as a forced destruction. Therefore, it supports the ability to retain the state.
        </p>
        <blockquote>
            <p>
                The sleeping nodes only do not have a DOM tree mounting relationship, but the virtual nodes and component instances still exist.
            </p>
        </blockquote>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
        &lt;button @click=&quot;handleGetRefClick&quot;&gt;Get ref&lt;/button&gt;
    &lt;/DemoRow&gt;
    &lt;p&gt;
        You can first hide the input box and then click &quot;Get ref&quot; to understand the destruction mechanism of the component in the sleep state.
    &lt;/p&gt;
    @if(model.isShow) {
        &lt;template keep-alive&gt;
            &lt;input ref=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;Enter content to observe the state&quot; /&gt;
        &lt;/template&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        isShow: true
    };

    handleClick() {
        this.model.isShow = !this.model.isShow;
    }

    handleGetRefClick() {
        MessageBox.alert(&quot;Retrieved: &quot; + this.$getRefs(&quot;input&quot;)?.length + &quot; virtual nodes&quot;);
    }
}
&lt;/script&gt;


&lt;style scoped&gt;
button {
    margin-right: 10px;
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <div class="warning">
            <p>
                When the parent component or the component itself is destroyed, if the
                <code>isKeepalive</code>
                property is
                <code>false</code>
                or there is a requirement for forced destruction, we will destroy all components that retain the state in sequence from top to bottom.
            </p>
        </div>
        <h3>transition-name/transition-type (Animation)</h3>
        <p>
            <code>transition-name</code>
            /
            <code>transition-type</code>
            are node animation functional attributes provided by Joker Core. This attribute provides two types of state animations,
            <code>enter</code>
            and
            <code>leave</code>
            , corresponding to the mounting and destruction of components respectively.
        </p>
        <p>
            Let's first look at an example. This example uses the animations in the
            <code>joker.front/ui</code>
            component library to demonstrate its working principle:
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.isShow) {
        &lt;div class=&quot;demo&quot; transition-name=&quot;jk-fade-in&quot;&gt;&lt;/div&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        isShow: true
    };
    handleClick() {
        this.model.isShow = !this.model.isShow;
    }
}
&lt;/script&gt;

&lt;style scoped&gt;
.demo {
    height: 100px;
    width: 100px;
    background: var(--jk-color-primary);
}
&lt;/style&gt;

</code></pre>
        </DemoContainer>
        <p>
            We have six CSS classes, which are used to define the enter and leave transition effects. Each transition effect category (
            <code>enter</code>
            and
            <code>leave</code>
            ) has three corresponding style classes. The following are the three style classes corresponding to the enter effect:
        </p>
        <ul>
            <li>
                <strong>from</strong>
                serves as the starting style of the animation start and will be added to the node when the animation starts.
            </li>
            <li>
                After the
                <code>from</code>
                style is added, after waiting for the next-frame animation processing to be completed, the
                <strong>active</strong>
                style will be added, the
                <strong>from</strong>
                style will be removed, and the
                <strong>to</strong>
                style will be added immediately after the removal.
            </li>
        </ul>
        <p>
            <img src="/base/transition-name.png" alt="transition-name" />
        </p>
        <pre><code class="language-scss">.jk-fade-in-enter-active,
.jk-fade-in-leave-active {
    transition: all 0.2s cubic-bezier(0.55, 0, 0.1, 1);
}
.jk-fade-in-enter-from,
.jk-fade-in-leave-to {
    opacity: 0;
}
</code></pre>
        <p>
            The
            <code>transition-type</code>
            property is
            <code>transition</code>
            by default. Of course, we can also specify this property as
            <code>animation</code>
            to complete the animation using
            <code>animation</code>
            .
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.isShow) {
        &lt;div class=&quot;demo&quot; transition-name=&quot;jk-dialog-fade&quot; transition-type=&quot;animation&quot;&gt;&lt;/div&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        isShow: true
    };
    handleClick() {
        this.model.isShow = !this.model.isShow;
    }
}
&lt;/script&gt;

&lt;style scoped lang=&quot;scss&quot;&gt;
.demo {
    height: 100px;
    width: 100px;
    background: var(--jk-color-primary);
}

.jk-dialog-fade-enter-from {
    opacity: 0;
}

.jk-dialog-fade-enter-active {
    animation: dialog-fade-in 0.3s;
}
.jk-dialog-fade-leave-active {
    animation: dialog-fade-out 0.3s;
}

@keyframes dialog-fade-in {
    0% {
        transform: translate3d(0, -20px, 0);
        opacity: 0;
    }
    100% {
        transform: translate3d(0, 0, 0);
        opacity: 1;
    }
}

@keyframes dialog-fade-out {
    0% {
        transform: translate3d(0, 0, 0);
        opacity: 1;
    }
    100% {
        transform: translate3d(0, -20px, 0);
        opacity: 0;
    }
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                Note that since the Joker template does not limit the number of root nodes, when using the animation property for a component, it will only act on the
                <strong>first-level &amp;&amp; first</strong>
                Element element of the component.
            </p>
        </blockquote>
        <h3>append-to (Change Output Location) [High-order API]</h3>
        <p>
            In component development, it is often necessary to project the node content within a component, such as a dropdown menu or a pop-up window, into a container outside the component. When a component needs to be independently mounted and detached from the original DOM structure, the content can be directly injected into the
            <strong>body</strong>
            . At this time, a specific property can be used to quickly achieve this requirement.
        </p>
        <pre><code class="language-html">&lt;div append-to=&quot;body&quot;&gt;I'm a div&lt;/div&gt;
</code></pre>
        <blockquote>
            <p>
                Here, it should be noted that we only modify the Render rendering relationship of the node, but it will not affect the
                <a href="/base/vnode" target="_blank">VNode</a>
                tree structure. The virtual node tree will still exist according to the hierarchical relationship within our component. We can still use the
                <code>$getRef</code>
                method to obtain it, and when we use the
                <strong>outside</strong>
                event modifier, even if its output structure has changed, it will still be affected by the
                <a href="/base/vnode" target="_blank">VNode</a>
                tree structure.
            </p>
        </blockquote>
        <p>Next, let's use an example to show the working principle:</p>
        <p>
            We use
            <code>append-to</code>
            to output an
            <strong>absolute</strong>
            -positioned element block to the body.
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo5)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
        &lt;button @click=&quot;handleFindClick&quot;&gt;Check if there is an element with ref='demo' in the current component&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.isShow) {
        &lt;div @click=&quot;hide&quot; class=&quot;demo&quot; ref=&quot;demo&quot; append-to=&quot;body&quot;&gt;I'm appended to the body&lt;/div&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        isShow: false
    };
    handleClick() {
        this.model.isShow = !this.model.isShow;
    }

    handleFindClick() {
        MessageBox.alert(`Found ` + this.$getRefs(&quot;demo&quot;)?.length + &quot; elements&quot;);
    }

    hide() {
        this.model.isShow = false;
    }
}
&lt;/script&gt;

&lt;style scoped&gt;
.demo {
    height: 100px;
    width: 100px;
    position: absolute;
    top: 100px;
    left: 50%;
    color: #fff;
    line-height: 2;
    cursor: pointer;
    text-align: center;
    transform: translateX(-50%);
    background: var(--jk-color-primary);
}

button {
    margin-right: 10px;
}
&lt;/style&gt;

</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                <code>append-to</code>
                supports two types of values, namely:
                <code>VNode.Node</code>
                and
                <code>string</code>
                . When it is a
                <code>string</code>
                , it will obtain the target container according to
                <strong>document.querySelector</strong>
                .
            </p>
        </blockquote>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo5 from "../../../examples/base/template-property/demo5.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/template-property/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/template-property/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/template-property/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/template-property/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo5,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>