<template>
    <div ref="container" class="joker-demo-container">
        <h2>Built-in Properties</h2>
        <p>
            This section focuses on the efficient built-in properties in templates. These properties are designed to assist developers in quickly addressing common development scenarios and improving productivity.
        </p>
        <h3>ref (Marker)</h3>
        <p>
            Using these properties, you can mark tags so that when using methods like
            <code>$getRef</code>
            from the
            <a href="#base/component-api">Component API</a>
            , you can quickly locate these marked tags.
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;div ref=&quot;myDiv&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    export default class extends Component {
        test() {
            this.$getRef(&quot;myDiv&quot;);
        }
    }
&lt;/script&gt;
</code></pre>
        <h3>keep-alive (State Preservation)</h3>
        <p>
            Configure this property to preserve the state of a
            <strong>component</strong>
            , allowing it to retain its state during render/destruction toggles. This property is typically used in conjunction with the
            <code>if</code>
            directive.
        </p>
        <p>The example below demonstrates its usage:</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.isShow) {
        &lt;template keep-alive&gt;
            &lt;input type=&quot;text&quot; placeholder=&quot;Enter content to observe the state&quot; /&gt;
        &lt;/template&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        isShow: true
    };

    handleClick() {
        this.model.isShow = !this.model.isShow;
    }
}
&lt;/script&gt;


</code></pre>
        </DemoContainer>
        <p>
            This property must be applied to
            <strong>component-type</strong>
            tags. Alternatively, you can use a virtual component wrapper, as shown in the example above, to achieve state preservation.
        </p>
        <p>
            Since data is retained, when will the component instance actually be destroyed? Let’s explore the destruction mechanism of
            <code>keep-alive</code>
            :
        </p>
        <p>
            From the
            <a href="/base/component-api" target="_blank">
                <code>$destroy</code>
                method
            </a>
            in Component Methods, we know that destruction only occurs when the method's parameter is set to
            <code>true</code>
            .
        </p>
        <p>
            In our earlier example using the
            <code>if</code>
            condition, the content was destroyed under non-matching conditions without forced destruction, which is why state preservation remains active.
        </p>
        <blockquote>
            <p>
                The sleeping node is no longer mounted in the DOM tree, but the virtual node and component instance still exist.
            </p>
        </blockquote>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
        &lt;button @click=&quot;handleGetRefClick&quot;&gt;Get ref&lt;/button&gt;
    &lt;/DemoRow&gt;
    &lt;p&gt;
        You can first hide the input box and then click &quot;Get ref&quot; to understand the destruction mechanism of the component in the sleep state.
    &lt;/p&gt;
    @if(model.isShow) {
        &lt;template keep-alive&gt;
            &lt;input ref=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;Enter content to observe the state&quot; /&gt;
        &lt;/template&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        isShow: true
    };

    handleClick() {
        this.model.isShow = !this.model.isShow;
    }

    handleGetRefClick() {
        MessageBox.alert(&quot;Retrieved: &quot; + this.$getRefs(&quot;input&quot;)?.length + &quot; virtual nodes&quot;);
    }
}
&lt;/script&gt;


&lt;style scoped&gt;
button {
    margin-right: 10px;
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <div class="warning">
            <p>
                When the parent or current component is destroyed, if the
                <code>isKeepalive</code>
                property is
                <code>false</code>
                or forced destruction is specified, all state-preserved child components will be destroyed in sequence.
            </p>
        </div>
        <h3>transition-name/transition-type (Animations)</h3>
        <p>
            <code>transition-name</code>
            and
            <code>transition-type</code>
            are properties provided by Joker Core for node animation. These properties support
            <code>enter</code>
            /
            <code>leave</code>
            state animations corresponding to component mounting and destruction.
        </p>
        <p>
            First, let's examine an example that uses animations from the
            <code>joker.front/ui</code>
            component library to demonstrate how it works:
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.isShow) {
        &lt;div class=&quot;demo&quot; transition-name=&quot;jk-fade-in&quot;&gt;&lt;/div&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        isShow: true
    };
    handleClick() {
        this.model.isShow = !this.model.isShow;
    }
}
&lt;/script&gt;

&lt;style scoped&gt;
.demo {
    height: 100px;
    width: 100px;
    background: var(--jk-color-primary);
}
&lt;/style&gt;

</code></pre>
        </DemoContainer>
        <p>
            There are six CSS classes that define the transition effects for entering and leaving. Each transition type (
            <code>enter</code>
            and
            <code>leave</code>
            ) has three associated style classes. Below are the three style classes for the enter effect:
        </p>
        <ul>
            <li>
                <strong>from</strong>
                : The starting style for the animation, added to the node when the animation begins.
            </li>
            <li>
                After the
                <code>from</code>
                style is applied, the
                <strong>active</strong>
                style is added in the next animation frame, and the
                <code>from</code>
                style is removed. Immediately afterward, the
                <strong>to</strong>
                style is applied.
            </li>
        </ul>
        <p>
            <img src="/base/transition-name.png" alt="transition-name" />
        </p>
        <pre><code class="language-scss">.jk-fade-in-enter-active,
.jk-fade-in-leave-active {
    transition: all 0.2s cubic-bezier(0.55, 0, 0.1, 1);
}
.jk-fade-in-enter-from,
.jk-fade-in-leave-to {
    opacity: 0;
}
</code></pre>
        <p>
            The
            <code>transition-type</code>
            property defaults to
            <strong>transition</strong>
            , but you can also set it to
            <strong>animation</strong>
            to use CSS animations.
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.isShow) {
        &lt;div class=&quot;demo&quot; transition-name=&quot;jk-dialog-fade&quot; transition-type=&quot;animation&quot;&gt;&lt;/div&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        isShow: true
    };
    handleClick() {
        this.model.isShow = !this.model.isShow;
    }
}
&lt;/script&gt;

&lt;style scoped lang=&quot;scss&quot;&gt;
.demo {
    height: 100px;
    width: 100px;
    background: var(--jk-color-primary);
}

.jk-dialog-fade-enter-from {
    opacity: 0;
}

.jk-dialog-fade-enter-active {
    animation: dialog-fade-in 0.3s;
}
.jk-dialog-fade-leave-active {
    animation: dialog-fade-out 0.3s;
}

@keyframes dialog-fade-in {
    0% {
        transform: translate3d(0, -20px, 0);
        opacity: 0;
    }
    100% {
        transform: translate3d(0, 0, 0);
        opacity: 1;
    }
}

@keyframes dialog-fade-out {
    0% {
        transform: translate3d(0, 0, 0);
        opacity: 1;
    }
    100% {
        transform: translate3d(0, -20px, 0);
        opacity: 0;
    }
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                Note: Since Joker’s template does not restrict the number of root nodes, when animation properties are applied to a component, they will only affect the
                <strong>first-level</strong>
                and
                <strong>first</strong>
                Element node of that component.
            </p>
        </blockquote>
        <h3>append-to (Rendering Location Change) [Advanced API]</h3>
        <p>
            In component development, it is often necessary to project node content (e.g., dropdown menus or pop-ups) outside the component container. When a component needs to be independently mounted and detached from its original DOM structure, content can be directly injected into the
            <strong>body</strong>
            using this property to quickly fulfill the requirement.
        </p>
        <pre><code class="language-html">&lt;div append-to=&quot;body&quot;&gt;I am a div&lt;/div&gt;
</code></pre>
        <blockquote>
            <p>
                Note that this only changes the node’s render relationship and does not affect the
                <a href="/base/vnode" target="_blank">VNode</a>
                tree structure. The virtual node tree still follows the component’s hierarchy. You can still use the
                <code>$getRef</code>
                method to retrieve it, and when using the
                <strong>outside</strong>
                event modifier, even if the rendering structure changes, it remains influenced by the
                <a href="/base/vnode" target="_blank">VNode</a>
                tree.
            </p>
        </blockquote>
        <p>Let’s illustrate how this works with an example:</p>
        <p>
            We use
            <code>append-to</code>
            to render an
            <strong>absolute</strong>
            positioned element block into the
            <code>body</code>
            .
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo5)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle&lt;/button&gt;
        &lt;button @click=&quot;handleFindClick&quot;&gt;Check if there is an element with ref='demo' in the current component&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.isShow) {
        &lt;div @click=&quot;hide&quot; class=&quot;demo&quot; ref=&quot;demo&quot; append-to=&quot;body&quot;&gt;I'm appended to the body&lt;/div&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        isShow: false
    };
    handleClick() {
        this.model.isShow = !this.model.isShow;
    }

    handleFindClick() {
        MessageBox.alert(`Found ` + this.$getRefs(&quot;demo&quot;)?.length + &quot; elements&quot;);
    }

    hide() {
        this.model.isShow = false;
    }
}
&lt;/script&gt;

&lt;style scoped&gt;
.demo {
    height: 100px;
    width: 100px;
    position: absolute;
    top: 100px;
    left: 50%;
    color: #fff;
    line-height: 2;
    cursor: pointer;
    text-align: center;
    transform: translateX(-50%);
    background: var(--jk-color-primary);
}

button {
    margin-right: 10px;
}
&lt;/style&gt;

</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                <code>append-to</code>
                supports two types of values:
                <code>VNode.Node</code>
                and
                <code>string</code>
                . When a string is provided, it retrieves the target container via
                <strong>document.querySelector</strong>
                .
            </p>
        </blockquote>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo5 from "../../../examples/base/template-property/demo5.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/template-property/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/template-property/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/template-property/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/template-property/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo5,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>