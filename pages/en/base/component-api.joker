<template>
    <div ref="container" class="joker-demo-container">
        <h2>Component Methods</h2>
        <p>
            Our component development is based on the powerful library
            <code>
                @("@joker.front/core")
            </code>
            . It provides developers with a range of tools and APIs, including lifecycle hooks, API functions, and properties, which help us develop components more efficiently and conveniently. In this chapter, we will delve into the composition of a component class, allowing you to understand how to leverage this library to create feature-rich and high-performance components.
        </p>
        <h3>Prerequisites</h3>
        <p>Before reading this chapter, you should have a basic understanding of the following:</p>
        <ul>
            <li>
                <p>
                    <a href="https://www.typescriptlang.org/" target="_blank">TypeScript Programming</a>
                </p>
            </li>
            <li>
                <p>
                    <a href="/base/component-lifecycle" target="_blank">Joker Lifecycle</a>
                </p>
            </li>
        </ul>
        <p>
            The built-in functions provided by Joker Core all start with
            <code>$</code>
            , such as:
            <code>this.$watch</code>
            ,
            <code>$destroy</code>
            , etc. Next, let’s explore the built-in functions Joker Core provides:
        </p>
        <h3>Component Mounting ($mount)</h3>
        <p>This function is typically called by external programs to mount the current component.</p>
        <pre><code class="language-ts">import MyComponent from &quot;my-component.joker&quot;;

let myComponent = new MyComponent();
myComponent.$mounted(document.getElementById(&quot;app&quot;));
</code></pre>
        <p>Try the example below to experience component mounting.</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Click me to load the child component&lt;/button&gt;
    &lt;div ref=&quot;container&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    isMounted = false;

    handleClick() {
        if (this.isMounted) return;

        this.isMounted = true;

        new MyComponent().$mount(this.$getRef(&quot;container&quot;)?.output);
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Description</th>
                    <th>Type</th>
                    <th>Default</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>root</td>
                    <td>The container to mount to, often used to mount a component to a DOM node</td>
                    <td>Element/VNode.Component</td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>
        <blockquote>
            <p>
                The
                <code>root</code>
                parameter is optional. If no
                <code>root</code>
                is provided, the component's template will not render, allowing it to exist purely as a functional mixin for additional features.
            </p>
        </blockquote>
        <h3>Component Destruction ($destroy)</h3>
        <p>
            Calling the
            <code>$destroy</code>
            method of a component instance actively unloads the component.
        </p>
        <pre><code class="language-ts">import MyComponent from &quot;my-component.joker&quot;;

let myComponent = new MyComponent();
myComponent.$mounted(document.getElementById(&quot;app&quot;));

// Unload
myComponent.$destroy();
</code></pre>
        <p>
            Explore
            <code>destroy</code>
            with the following example:
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent ref=&quot;children&quot; /&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Destroy the child component&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent
    };

    handleClick() {
        //选中组件并销毁它
        this.$getRef(&quot;children&quot;)?.component.$destroy();
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <p>
            For components preserving state, calling the destroy method won't completely destroy the component; it will retain data state in the background. Use the parameter
            <code>force:true</code>
            to fully destroy it.
        </p>
        <p>See how the destroy method works for state-preserving components:</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;div ref=&quot;container&quot;&gt;&lt;/div&gt;
    &lt;DemoRow&gt;
        @if(model.isMount === false) {
            &lt;button @click=&quot;handleMountClick&quot;&gt;Load the child component&lt;/button&gt;
        }
        else {
            &lt;p&gt;
                You can enter text in the input box of the child component to experience the effect of maintaining the data state after destruction.
            &lt;/p&gt;
            &lt;button @click=&quot;handleDestroyClick&quot;&gt;Destroy the child component&lt;/button&gt;
            &lt;button @click=&quot;handleDestroyClick(true)&quot;&gt;Force destroy the child component&lt;/button&gt;
        }
    &lt;/DemoRow&gt;
&lt;/template&gt;

&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    model = {
        isMount: false
    };
    components = {
        MyComponent
    };

    //组件实例
    myComponent?: Component;

    handleMountClick() {
        //“??”代表如果有值则使用原始值，没有则初始化新的组件实例
        this.myComponent ??= new MyComponent(undefined, undefined, true);

        this.myComponent.$mount(this.$getRef(&quot;container&quot;)?.output);

        this.model.isMount = true;
    }

    handleDestroyClick(e: VNode.Event, force?: boolean) {
        //force 代表是否强制销毁
        this.myComponent?.$destroy(force);

        this.model.isMount = false;

        if (force) {
            //清除缓存实例
            this.myComponent = undefined;
        }
    }
}
&lt;/script&gt;
&lt;style scoped&gt;
button {
    margin-right: 10px;
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <blockquote>
            <p>Detailed explanations on data state preservation will be covered in a later chapter.</p>
        </blockquote>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Description</th>
                    <th>Type</th>
                    <th>Default</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>force</td>
                    <td>Whether to force destroy</td>
                    <td>Boolean</td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>
        <h3>Data Observation ($watch)</h3>
        <p>
            The
            <code>$watch</code>
            method observes changes in hijacked properties and triggers corresponding functions when values change.
        </p>
        <pre><code class="language-ts">import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        value: &quot;v1&quot;
    };

    mounted() {
        let [val, destroyWatch] = this.$watch(
            () =&gt; this.model.value,
            (nv, ov) =&gt; {
                // Value changed, new value is nv, old value is ov
            }
        );
    }
}
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;p&gt;
        The current value is: @model.value
    &lt;/p&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Change the value to the current time&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        value: &quot;v1&quot;
    };

    mounted() {
        this.$watch(
            () =&gt; this.model.value,
            (nv, ov) =&gt; {
                MessageBox.alert(`value change：${ov}=&gt;${nv}`);
            }
        );
    }

    handleClick() {
        this.model.value = new Date().toLocaleTimeString();
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                Note: The observed value must be a hijacked property (properties within
                <code>model</code>
                are hijacked via
                <code>observer</code>
                operations before component mounting). For details on data hijacking, see
                <a href="/base/observer" target="_blank">here</a>
                .
            </p>
        </blockquote>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Description</th>
                    <th>Type</th>
                    <th>Default</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>express</td>
                    <td>The expression to observe</td>
                    <td>Function</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>callback</td>
                    <td>Callback function upon change</td>
                    <td>
                        <code>(nv:any, ov:any)=&gt;void</code>
                        (receives
                        <strong>new value</strong>
                        and
                        <strong>old value</strong>
                        )
                    </td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>forceCallBack</td>
                    <td>Force callback even if value is unchanged</td>
                    <td>
                        boolean (optional, default
                        <code>false</code>
                        )
                    </td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>
        <h3>Node Observation ($watchNode)</h3>
        <p>Node observation tracks virtual node changes, including removal, addition, or updates.</p>
        <p>
            Before using this method, it’s recommended to understand
            <a href="/base/vnode" target="_blank">VNode</a>
            . Virtual nodes act as bridges between DOM and Script, mapping the actual DOM tree as a virtual node tree to facilitate communication and decouple the rendering layer (e.g., for mini-programs, native mobile rendering). The
            <code>Core</code>
            provides
            <code>H5-Render</code>
            by default (rendering virtual nodes to H5 DOM nodes).
        </p>
        <p>Example:</p>
        <pre><code class="language-ts">import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        value: &quot;v1&quot;
    };

    mounted() {
        this.$watchNode(&quot;node_ref&quot;, (node, type, property) =&gt; {
            // node: The changed node
            // type: Change type
            // property: The property name if attributes were changed
        });
    }
}
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo5)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        @if(model.show) {
            &lt;div ref=&quot;refNode&quot; class=&quot;@model.className&quot;&gt;I'm a paragraph&lt;/div&gt;
        }
    &lt;/DemoRow&gt;
    &lt;button @click=&quot;handleChangeShow&quot;&gt;Toggle the display state&lt;/button&gt;
    @if(model.show) {
        &lt;button @click=&quot;handleChangeClassName&quot;&gt;Toggle the class name&lt;/button&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { Message } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        show: true,
        className: &quot;normal&quot;
    };

    mounted() {
        this.$watchNode(&quot;refNode&quot;, (node, type, property) =&gt; {
            Message(
                `From Demo: The node has been ${type}${
                    type === &quot;update&quot; ? &quot;, and the property value is: &quot; + property : &quot;&quot;
                }.`
            );
        });
    }

    handleChangeShow() {
        this.model.show = !this.model.show;
    }

    handleChangeClassName() {
        this.model.className = this.model.className === &quot;normal&quot; ? &quot;larger&quot; : &quot;normal&quot;;
    }
}
&lt;/script&gt;


&lt;style lang=&quot;scss&quot; scoped&gt;
button {
    margin-right: 10px;
}

.larger {
    font-size: 24px;
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Description</th>
                    <th>Type</th>
                    <th>Default</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>ref</td>
                    <td>The ref of the node to observe</td>
                    <td>string</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>callback</td>
                    <td>Change callback function</td>
                    <td>
                        <code>
                            (node:VNode.Node, type:&quot;append&quot;/&quot;remove&quot;/&quot;update&quot;/&quot;after-enter&quot;/&quot;after-leave&quot;, property:string)=&gt;void
                        </code>
                        (receives
                        <strong>changed node</strong>
                        ,
                        <strong>change type</strong>
                        , and
                        <strong>property value</strong>
                        )
                    </td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>
        <h3>Fetching Nodes ($getRef and $getRefs)</h3>
        <p>
            Mark elements with the
            <code>ref</code>
            attribute to fetch them via
            <code>$getRef</code>
            or
            <code>$getRefs</code>
            . These methods return virtual Nodes (VNodes).
        </p>
        <pre><code class="language-ts">// Fetch a single node
this.$getRef&lt;VNode.Element&gt;(&quot;ref&quot;);

// Fetch multiple nodes
this.$getRefs(&quot;ref&quot;);
</code></pre>
        <p>
            <code>$getRef</code>
            returns at most one VNode (the first match if multiple refs exist).
            <br />
            <code>$getRefs</code>
            returns all nodes with the specified
            <code>ref</code>
            in the current component (excluding child components).
        </p>
        <p>
            Both methods support TypeScript generics (default
            <code>VNode.Node</code>
            ), allowing specific node type returns for easier manipulation.
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo6)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;ul&gt;
            @for(let i = 0; i &lt; 5; i++) {
                &lt;li ref=&quot;li&quot;&gt;
                    I'm line @i
                &lt;/li&gt;
            }
        &lt;/ul&gt;
    &lt;/DemoRow&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Get with getRef&lt;/button&gt;
    &lt;button @click=&quot;handleClick(true)&quot;&gt;Get with getRefs&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    handleClick(e: VNode.Event, isGetRefs?: boolean) {
        if (isGetRefs) {
            MessageBox.alert(`getRefs: ${this.$getRefs(&quot;li&quot;)?.length} nodes are retrieved.`);
        } else {
            MessageBox.alert(`getRef: The retrieved node content is: ${this.$getRef(&quot;li&quot;)?.output.innerHTML}`);
        }
    }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
button {
    margin-right: 10px;
}
&lt;/style&gt;

</code></pre>
        </DemoContainer>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Description</th>
                    <th>Type</th>
                    <th>Default</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>ref</td>
                    <td>Node ref value</td>
                    <td>string</td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>
        <blockquote>
            <p>
                Additionally, the
                <code>$refs</code>
                property holds all marked nodes (see
                <a href="/base/component-property" target="_blank">
                    <code>$refs</code>
                    in Component Properties
                </a>
                ).
            </p>
        </blockquote>
        <h3>Events ($on / $off / $trigger)</h3>
        <p>These methods form the core of component event mechanisms:</p>
        <ul>
            <li>
                <code>$on</code>
                : Registers an event.
            </li>
            <li>
                <code>$off</code>
                : Unregisters an event.
            </li>
            <li>
                <code>$trigger</code>
                : Triggers an event (commonly used for broadcasting events).
            </li>
        </ul>
        <p>Usage example:</p>
        <pre><code class="language-ts">// Event registration
this.$on(&quot;eventName&quot;, (e: VNode.Event, param: any) =&gt; {
    // e: Event object for handling event flow and data
    // param: Additional event parameters
});

// Event unregistration
this.$off(&quot;eventName&quot;, callbackFunction);

// Event triggering (optionally pass the event object for forwarding)
this.$trigger(&quot;eventName&quot;, eventParam, e?: VNode.Event);
</code></pre>
        <p>Example:</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo7)">
            <pre><code class="language-html">&lt;template&gt;
    @if(model.hasOn) {
        &lt;button @click=&quot;handleOffClick&quot;&gt;Unbind the event&lt;/button&gt;
        &lt;button @click=&quot;handleTriggerClick&quot;&gt;Trigger the event&lt;/button&gt;
    }
    else {
        &lt;button @click=&quot;handleOnClick&quot;&gt;Bind the event&lt;/button&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        hasOn: false
    };
    handleOnClick() {
        this.model.hasOn = true;
        this.$on(&quot;event1&quot;, this.eventHandle);
    }

    handleOffClick() {
        this.model.hasOn = false;
        this.$off(&quot;event1&quot;, this.eventHandle);
    }

    handleTriggerClick() {
        this.$trigger(&quot;event1&quot;, &quot;I'm a string parameter. Did you receive it?&quot;);
    }

    eventHandle = (e: VNode.Event&lt;string&gt;) =&gt; {
        MessageBox.alert(e.data);
    };
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
button {
    margin-right: 10px;
}
&lt;/style&gt;

</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                To monitor all events from a component, use the
                <code>*</code>
                wildcard (e.g.,
                <code>$on('*', ...)</code>
                ). This works only in
                <code>$on</code>
                , not in template event bindings.
            </p>
        </blockquote>
        <p>Advanced usage:</p>
        <pre><code class="language-ts">this.childrenComponent.$on(&quot;*&quot;, (e: VNode.Event) =&gt; {
    if (e.eventName === &quot;click&quot;) {
        // Handle click
        return;
    }
    
    // Forward other events
    this.$trigger(e.eventName, e.data, e);
});
</code></pre>
        <h4>VNode.Event Overview</h4>
        <p>
            <code>VNode.Event</code>
            is the event handling object in Joker, passed as the first parameter in
            <code>$on</code>
            . Its
            <code>data</code>
            property holds event parameters (generics-supported).
        </p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Description</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>eventName</td>
                    <td>Event name</td>
                    <td>string</td>
                </tr>
                <tr>
                    <td>event</td>
                    <td>Native event object (platform-specific)</td>
                    <td>any</td>
                </tr>
                <tr>
                    <td>target</td>
                    <td>Target VNode of the event</td>
                    <td>VNode.Node / undefined</td>
                </tr>
                <tr>
                    <td>data</td>
                    <td>Event parameters</td>
                    <td>
                        <code>&lt;T&gt;</code>
                        : any
                    </td>
                </tr>
                <tr>
                    <td>preventDefault</td>
                    <td>Prevents default event behavior</td>
                    <td>function</td>
                </tr>
                <tr>
                    <td>stopPropagation</td>
                    <td>Stops event propagation</td>
                    <td>function</td>
                </tr>
            </tbody>
        </table>
        <h3>Event Registration and Triggering</h3>
        <p>Parent Component:</p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;button @click=&quot;handleClick('param1', 'param2')&quot;&gt;Button&lt;/button&gt;
    &lt;MyComponent @click=&quot;handleMyComponentClick('param1', 'param2')&quot;&gt;&lt;/MyComponent&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component, VNode } from &quot;@joker.front/core&quot;;
    import { MessageBox } from &quot;@joker.front/ui&quot;;
    import MyComponent from &quot;./children1.joker&quot;;

    export default class extends Component {
        components = {
            MyComponent
        };
        handleMyComponentClick(e: VNode.Event&lt;string&gt;, param1: string, param2: string) {
            // Event-passed parameter
            e.data;
            // Extended parameters
            param1;
            param2;
        }

        handleClick(e: VNode.Event, param1: string, param2: string) {
            // Extended parameters
            param1;
            param2;
        }
    }
&lt;/script&gt;
</code></pre>
        <p>Child Component:</p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Child Button&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;

    export default class extends Component {
        handleClick() {
            this.$trigger(&quot;click&quot;, &quot;Child component parameter&quot;);
        }
    }
&lt;/script&gt;
</code></pre>
        <p>Live example:</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo8)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;button @click=&quot;handleClick('param1', 'param2')&quot;&gt;按钮&lt;/button&gt;
    &lt;MyComponent @click=&quot;handleMyComponentClick('param1', 'param2')&quot;&gt;按钮&lt;/MyComponent&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;
import MyComponent from &quot;./children1.joker&quot;;

export default class extends Component {
    components = {
        MyComponent
    };
    handleMyComponentClick(e: VNode.Event&lt;string&gt;, param1: string, param2: string) {
        MessageBox.alert(
            `&lt;p&gt;e.data:${e.data};&lt;/p&gt;
        &lt;p&gt;param1:${param1};&lt;/p&gt;
        &lt;p&gt;param2:${param2};&lt;/p&gt;`,
            {
                useHtml: true
            }
        );
    }

    handleClick(e: VNode.Event, param1: string, param2: string) {
        MessageBox.alert(
            `&lt;p&gt;e.data:${e.data};&lt;/p&gt;
        &lt;p&gt;param1:${param1};&lt;/p&gt;
        &lt;p&gt;param2:${param2};&lt;/p&gt;`,
            {
                useHtml: true
            }
        );
    }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
button {
    margin-right: 10px;
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <p>
            In the example above,
            <code>e.data</code>
            carries cross-component data, while parameters like
            <code>param1, param2</code>
            are local to the event handler.
        </p>
        <h3>Property Synchronization ($syncProp)</h3>
        <p>
            Before using this method, familiarize yourself with
            <a href="/base/component-property" target="_blank">
                <code>model</code>
                and
                <code>props</code>
            </a>
            .
        </p>
        <p>
            Since
            <code>props</code>
            are read-only, internal state changes require
            <code>model</code>
            . To sync
            <code>props</code>
            to
            <code>model</code>
            , use
            <code>$syncProp</code>
            :
        </p>
        <pre><code class="language-ts">export default class extends Component&lt;{
    money: number;
}&gt; {
    model = {
        money: 0
    };

    created() {
        this.$syncProp(&quot;money&quot;);
    }

    handleClick() {
        this.model.money = 300; // Internal state change
    }
}
</code></pre>
        <p>Overloads for different scenarios:</p>
        <pre><code class="language-ts">// Full signature
this.$syncProp(propKey: keyof T, modelKey: string, convertVal?: (val: any) =&gt; any);

// Shorthand (same property name, type conversion)
this.$syncProp('propsValue', (val:string) =&gt; parseInt(val));

// Basic (same property name and type)
this.$syncProp('propsValue');
</code></pre>
        <h3>Node Animation ($nodeTransition) [Advanced]</h3>
        <p>Trigger node animations (e.g., fade-in/out) programmatically:</p>
        <pre><code class="language-ts">this.$nodeTransition(
    nodeOrRef: string | VNode.Node, // Node/ref to animate
    mode: &quot;enter&quot; | &quot;leave&quot;,       // Animation phase
    name?: string,                 // Animation class name
    callBack?: Function,           // Post-animation callback
    type?: &quot;transition&quot; | &quot;animation&quot; // Animation type
);
</code></pre>
        <p>
            Example (using
            <code>
                @joker.front
                /ui
            </code>
            animations):
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo9)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        @if(!model.isShow) {
            &lt;button @click=&quot;handleClick(true)&quot;&gt;Show&lt;/button&gt;
        }
        else {
            &lt;button @click=&quot;handleClick(false)&quot;&gt;Hide&lt;/button&gt;
        }
    &lt;/DemoRow&gt;
    &lt;div ref=&quot;demo&quot; class=&quot;demo&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;
import { Message } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        isShow: true
    };
    handleClick(e: VNode.Event, isShow: boolean) {
        if (isShow) {
            this.$getRef(&quot;demo&quot;)!.output.style.display = &quot;block&quot;;
        }

        this.$nodeTransition(&quot;demo&quot;, isShow ? &quot;enter&quot; : &quot;leave&quot;, &quot;jk-zoom-in-top&quot;, () =&gt; {
            Message(&quot;The animation is over.&quot;);

            if (!isShow) {
                this.$getRef(&quot;demo&quot;)!.output.style.display = &quot;none&quot;;
            }
            this.model.isShow = isShow;
        });
    }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
.demo {
    width: 150px;
    height: 150px;
    background: var(--jk-color-success);
}

button {
    margin-right: 10px;
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <h3>Awaiting Next Render ($nextUpdatedRender)</h3>
        <p>
            Joker renders changes instantly. For async components, use
            <code>$nextUpdatedRender</code>
            to wait for completion:
        </p>
        <pre><code class="language-ts">// Method 1
this.$nextUpdatedRender(() =&gt; {
    // Rendering complete
});

// Method 2 (async/await)
await this.$nextUpdatedRender();
</code></pre>
        <h3>Template Rendering ($render) [Advanced]</h3>
        <p>
            Dynamically change templates via
            <code>$render</code>
            (advanced usage):
        </p>
        <pre><code class="language-ts">/**
 * Render a template
 * @param asts New AST nodes
 * @param keepalive Preserve alive components during re-render (use with caution)
 */
this.$render(asts:AST.Node[] | (()=&gt;AST.Node[]), keepalive?: boolean);
</code></pre>
        <p>
            For AST details, see
            <a href="/base/ast" target="_blank">here</a>
            .
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo10)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;I'm the button from the original template.&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    handleClick() {
        this.$render((h) =&gt; {
            return [h.createElement(&quot;div&quot;, undefined, [h.createText(&quot;I'm the newly rendered text.&quot;)])];
        });
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                Template rendering has its own lifecycle—old templates are destroyed (nodes, data, events) before rendering new ones. See
                <a href="/base/ast" target="_blank">here</a>
                .
            </p>
        </blockquote>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo9 from "../../../examples/base/component-api/demo9.joker";
import DEMO_JOKER_demo8 from "../../../examples/base/component-api/demo8.joker";
import DEMO_JOKER_demo7 from "../../../examples/base/component-api/demo7.joker";
import DEMO_JOKER_demo6 from "../../../examples/base/component-api/demo6.joker";
import DEMO_JOKER_demo5 from "../../../examples/base/component-api/demo5.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/component-api/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/component-api/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/component-api/demo2.joker";
import DEMO_JOKER_demo10 from "../../../examples/base/component-api/demo10.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/component-api/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo9,
        DEMO_JOKER_demo8,
        DEMO_JOKER_demo7,
        DEMO_JOKER_demo6,
        DEMO_JOKER_demo5,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo10,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>