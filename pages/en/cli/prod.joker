<template>
    <div ref="container" class="joker-demo-container">
        <h2>Building for Production</h2>
        <p>
            When deploying your application to a production environment, you can run the
            <code>joker build</code>
            command. By default, this command will use
            <code>&lt;root&gt;/index.html</code>
            as the build entry point and create an application bundle ready for static deployment.
        </p>
        <h3>Browser Compatibility</h3>
        <p>
            Production builds assume the target browsers can natively support modern JavaScript features. The Joker CLI by default supports browsers capable of natively parsing
            <a href="https://caniuse.com/es6-module" target="_blank">ESM script tags</a>
            ,
            <a href="https://caniuse.com/es6-module-dynamic-import" target="_blank">executing ESM dynamic imports</a>
            , and supporting
            <a href="https://caniuse.com/mdn-javascript_operators_import_meta" target="_blank">import.meta</a>
            :
        </p>
        <ul>
            <li>Chrome &gt;=87</li>
            <li>Firefox &gt;=78</li>
            <li>Safari &gt;=14</li>
            <li>Edge &gt;=88</li>
        </ul>
        <p>
            You can specify target browser versions using the
            <a href="/cli/setting-build" target="_blank">build.target</a>
            configuration, with minimum support down to ES2015.
        </p>
        <p>
            Note that Joker CLI only handles syntax transformation by default and doesn't include any polyfills. For supporting legacy browsers, you can use
            <a href="https://polyfill.io/" target="_blank">Polyfill.io</a>
            , a service that automatically generates polyfill bundles based on the user's browser User-Agent.
        </p>
        <p>
            For traditional browser compatibility scenarios, you can install and use the
            <code>
                @("@joker.front/cli-plugin-legacy")
            </code>
            plugin. This plugin automatically generates legacy-compatible builds with necessary polyfills that are loaded on-demand when the target browser lacks native ESM support.
        </p>
        <pre><code class="language-js">const { legacyPlugin } = require(&quot;@joker.front/cli-plugin-legacy&quot;);

module.exports = {
    plugins: [
        legacyPlugin({
            targets: [&quot;chrome 80&quot;, &quot;ie &gt;= 10&quot;]
        })
    ]
};
</code></pre>
        <h3>Customizing the Build</h3>
        <p>
            The build process can be customized through various
            <a href="/cli/setting-build" target="_blank">build configuration options</a>
            . Specifically, you can directly adjust the underlying
            <a href="https://rollupjs.org/configuration-options/" target="_blank">Rollup</a>
            options via
            <a href="/cli/setting-build" target="_blank">build.rollupOptions</a>
            :
        </p>
        <pre><code class="language-js">module.exports = {
    rollupOptions: {
        // https://rollupjs.org/configuration-options/
    }
};
</code></pre>
        <h3>Public Base Path</h3>
        <p>
            When deploying your project to a nested public path, you can specify the base path using the
            <a href="/cli/setting-public" target="_blank">base</a>
            configuration. This ensures all resource paths are rewritten accordingly. The option can also be set via CLI, e.g.,
            <code>joker build --base=/my/public/path/</code>
            .
        </p>
        <p>
            During build, resource URLs in JavaScript files,
            <code>url()</code>
            references in CSS, and resource references in HTML files are automatically adjusted to match the new base path, ensuring correct access post-deployment regardless of directory structure.
        </p>
        <h3>Output Directory</h3>
        <p>
            To customize the build output location, configure the
            <a href="/cli/setting-build" target="_blank">build.outDir</a>
            property or specify it via CLI:
        </p>
        <pre><code class="language-bash">joker build --outDir=./my-dist
</code></pre>
        <p>
            By default,
            <code>build.outDir</code>
            is set to the
            <code>dist</code>
            directory if not specified.
        </p>
        <h3>Chunking Strategy</h3>
        <p>
            Customize code splitting via
            <a href="/cli/setting-build" target="_blank">build.rollupOptions.output.manualChunks</a>
            . Refer to the
            <a href="https://rollupjs.org/configuration-options/#output-manualchunks" target="_blank">
                Rollup documentation
            </a>
            for configuration details.
        </p>
        <p>Joker CLI provides default chunking and path optimization:</p>
        <ul>
            <li>
                <code>node_modules</code>
                are bundled into
                <strong>vendor</strong>
                chunks.
            </li>
            <li>
                <code>import()</code>
                references generate chunks based on their paths rather than dumping everything into the root
                <code>dist</code>
                directory.
            </li>
        </ul>
        <p>
            You can extend this logic, e.g., to isolate
            <code>dayjs</code>
            from vendor bundles:
        </p>
        <pre><code class="language-js">module.exports = {
    rollupOptions: {
        output: {
            manualChunks: (id, api) =&gt; {
                if (id.includes(&quot;node_modules/dayjs&quot;)) {
                    // Custom chunking
                    return &quot;dayjs&quot;; 
                }
            }
        }
    }
};
</code></pre>
        <blockquote>
            <p>
                When
                <code>manualChunks</code>
                is defined as a
                <strong>function</strong>
                , it does not override Joker CLI's default rules. Custom rules execute first; if they return no value, Joker's defaults apply. We recommend
                <strong>against</strong>
                using an object for
                <code>manualChunks</code>
                as it prevents safe merging with Joker's logicâ€”always prefer functions to preserve async chunk paths and vendor splitting.
            </p>
        </blockquote>
        <h3>Library Mode [lib]</h3>
        <p>
            When developing browser-oriented libraries, creating a test/demo page is often essential, and Joker CLI provides a smooth development experience via
            <code>index.html</code>
            .
        </p>
        <p>
            For library publication builds, configure
            <a href="/cli/setting-build" target="_blank">build.lib</a>
            to externalize dependencies that shouldn't be bundled, optimizing library size and performance.
        </p>
        <pre><code class="language-js">module.exports = {
    lib: {
        entry: resolve(__dirname, &quot;lib/main.js&quot;),
        name: &quot;MyLib&quot;, 
        fileName: &quot;my-lib&quot;
    },
    rollupOptions: {
        // Ensure dependencies like echarts are externalized
        external: [&quot;echarts&quot;],
        output: {
            // Provide global variables for externalized dependencies in UMD builds
            globals: {
                echarts: &quot;echarts&quot; // Global variable name for echarts
            }
        }
    }
};
</code></pre>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>