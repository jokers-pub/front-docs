<template>
    <div ref="container" class="joker-demo-container">
        <h2>组件注册</h2>
        <p>该章节主要介绍如何去注册一个组件，包括私有组件和全局组件的注册机制。</p>
        <h3>私有组件注册</h3>
        <p>
            通过配置
            <code>component</code>
            属性来配置当前组件内的私有组件，组件的注册机制可查看
            <a href="/base/component-register" target="_blank">组件注册</a>
            。
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent /&gt;
    &lt;MyAsyncComponent /&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    import MyComponent from &quot;./children.joker&quot;;
    export default class extends Component {
        component = {
            MyComponent,
            MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent message=&quot;I'm a parameter.&quot; /&gt;
    &lt;MyAsyncComponent message=&quot;I'm a parameter.&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent,
        MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
    };
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>
            组件的注册是支持异步的，可以使用
            <code>()=&gt;import('component.joker')</code>
            的方式来进行组件的异步引用，异步引用组件不会随着父组件的初始化而被加载，直到该组件需要被渲染时才会进行加载，例如：
        </p>
        <pre><code class="language-html">&lt;template&gt;
    @if(false){
    &lt;MyAsyncComponent /&gt;
    }
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;

    export default class extends Component {
        component = {
            MyAsyncComponent: () =&gt; import(&quot;./async-children.joker&quot;)
        };
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Toggle the display state of the child component.&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.show) {
        &lt;MyAsyncComponent message=&quot;I'm a parameter.&quot; /&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { Component, VNode } from &quot;@joker.front/core&quot;;

export default class extends Component {
    components = {
        MyAsyncComponent: () =&gt; import(&quot;./async-children-import.joker&quot;)
    };
    model = {
        show: false
    };

    handleClick() {
        this.model.show = !this.model.show;
    }
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>可以通过上面的代码和控制台输出（网络）可以看到，异步组件会在被要求加载时才会被加载。</p>
        <h3>全局组件注册（registerGlobalComponent）</h3>
        <p>
            Core 核心库中提供了
            <code>registerGlobalComponent</code>
            函数用于注册全局组件，若注册为全局组件，即可在所有的组件内进行该组件的使用，避免重复注册。
        </p>
        <pre><code class="language-ts">import { registerGlobalComponent } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./components/my-component.joker&quot;;

//单个组件注册
registerGlobalComponent(&quot;my-componet&quot;, MyComponent);

//也支持多组件注册
registerGlobalComponent({
    &quot;my-componet&quot;: MyComponent,
    &quot;my-test-component&quot;: MyTestComponent,
    &quot;my-async-component&quot;: () =&gt; import(&quot;./components/async-component.joker&quot;)
    //...
});
</code></pre>
        <p>下面看一下全局组件的例子：</p>
        <pre><code class="language-ts">import { registerGlobalComponent } from &quot;@joker.front/core&quot;;

//我们在main.ts（入口）文件中注册全局组件
registerGlobalComponent({
    DemoRow: DemoRow
});
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        I'm a text within the global component. This global component comes with a built-in padding property.
    &lt;/DemoRow&gt;
&lt;/template&gt;

</code></pre>
        </DemoContainer>
        <p>
            全局组件注册，也同私有组件一样，支持异步组件的引入，异步组件不会随着项目启动而加载，直到它被渲染前才会被加载。
        </p>
        <blockquote>
            <p>
                我们不限制
                <strong>registerGlobalComponent</strong>
                函数的使用位置，但是我们还是建议在入口文件中使用它，这样可以更清晰更快速的了解一个项目的全局组件有哪些。
            </p>
        </blockquote>
        <h3>查找全局组件（getGlobalComponent）</h3>
        <p>
            Core 核心中也提供了
            <strong>getGlobalComponent</strong>
            获取全局组件的函数，我们可以通过该方法能动态判断是否有你需要的全局组件
        </p>
        <p>值的注意的是，该方法的返回类型有三种：</p>
        <ul>
            <li>
                <strong>undefined</strong>
                （未找到）
            </li>
            <li>
                <strong>ComponentConstructor</strong>
                （待初始化的组件类）
            </li>
            <li>
                <strong>ImportComponentConstructor</strong>
                （异步组件加载方法）
            </li>
        </ul>
        <pre><code class="language-ts">getGlobalComponent(&quot;my-component&quot;);
</code></pre>
        <h3>内置全局组件（template）</h3>
        <p>
            我们内部提供了一个虚拟容器节点，该节点只作为一个容器，并展示容器内的内容，该组件本身不会输出任何元素(Element)。
            我们可以使用这个组件来实现归组的功能，例如：
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;ul&gt;
        &lt;li&gt;我是固定列1&lt;/li&gt;
        &lt;li&gt;我是固定列2&lt;/li&gt;
        &lt;template ref=&quot;test&quot;&gt;
            &lt;li&gt;我是列3&lt;/li&gt;
            &lt;li&gt;我是列4&lt;/li&gt;
        &lt;/template&gt;
    &lt;/ul&gt;
&lt;/template&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;ul&gt;
            &lt;li&gt;I'm the fixed column 1&lt;/li&gt;
            &lt;li&gt;I'm the fixed column 2&lt;/li&gt;
            &lt;template ref=&quot;test&quot;&gt;
                &lt;li&gt;I'm the column 3&lt;/li&gt;
                &lt;li&gt;I'm the column 4&lt;/li&gt;
            &lt;/template&gt;
        &lt;/ul&gt;
    &lt;/DemoRow&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Get the number of non - fixed columns&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { VNode } from &quot;@joker.front/core&quot;;
import { Component } from &quot;@joker.front/core&quot;;
import { Message } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    handleClick() {
        let count = this.$getRef(&quot;test&quot;)?.find((n) =&gt; n instanceof VNode.Element).length || 0;

        Message(&quot;Got &quot; + count + &quot; non - fixed columns.&quot;);
    }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <h3>内置全局组件（component）</h3>
        <p>内置 component 用于渲染动态组件。</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo5)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleChangeComponet('Test1')&quot;&gt;Load Component 1&lt;/button&gt;
        &lt;button @click=&quot;handleChangeComponet('Test2')&quot;&gt;Load Component 2&lt;/button&gt;
    &lt;/DemoRow&gt;
    @if(model.name) {
        &lt;component name=&quot;@model.name&quot; message=&quot;I'm a parameter&quot; user-name=&quot;Zhang San&quot;&gt;
            &lt;span&gt;I'm the content&lt;/span&gt;
        &lt;/component&gt;
    }
&lt;/template&gt;
&lt;script&gt;
import { VNode } from &quot;@joker.front/core&quot;;
import { Component } from &quot;@joker.front/core&quot;;
import Test1 from &quot;./component-test1.joker&quot;;
import Test2 from &quot;./component-test2.joker&quot;;

export default class extends Component {
    model = {
        name: &quot;&quot;
    };
    components = {
        Test1,
        Test2
    };

    handleChangeComponet(e: VNode.Event, name: string) {
        this.model.name = name;
    }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
button {
    margin-right: 10px;
}
&lt;/style&gt;
</code></pre>
        </DemoContainer>
        <p>
            你可以通过
            <code>name</code>
            的方式来指定当前组件的名称，这个值可以是当前组件内私有组件的 name，也可以是全局组件的 name，同时 name 的变更会触发组件的渲染，以便渲染新的组件。
        </p>
        <p>
            你可以将该组件作为一个动态组件容器，它的参数传递、事件注册和其他组件一样，值得注意的是，它本身除了
            <strong>keep-alive</strong>
            、
            <strong>name</strong>
            、
            <strong>transition-name</strong>
            、
            <strong>ref</strong>
            属性外，他都会透传到你实际渲染的组件。事件的处理机制同理， 我们在该组件内监听渲染组件的
            <code>*</code>
            事件（可以查看$on API），然后将所有事件向上广播传递，本身不做事件处理和拦截。
        </p>
        <p>
            当然除了使用
            <strong>name</strong>
            去渲染动态组件，我们也提供了
            <code>loadComponent</code>
            API，可以调用该方法实现更复杂的渲染机制。
        </p>
        <pre><code class="language-ts">import { Component, ComponentContainer } from &quot;@joker.front/core&quot;;

export default class extends Component {
    testFunction() {
        //渲染组件
        this.$getRef&lt;VNode.Component&lt;ComponentContainer&gt;&gt;(&quot;test&quot;)?.component.loadComponent(&quot;name&quot;);
    }
}
</code></pre>
        <p>
            由于它本身是一个动态组件，并且支持保持数据状态（keep-alive），所以我们也提供了
            <code>removeCache</code>
            API，来清除某一个渲染过组件的缓存。
        </p>
        <pre><code class="language-ts">import { Component, ComponentContainer } from &quot;@joker.front/core&quot;;

export default class extends Component {
    testFunction() {
        //渲染组件
        this.$getRef&lt;VNode.Component&lt;ComponentContainer&gt;&gt;(&quot;test&quot;)?.component.removeCache(&quot;name&quot;);
    }
}
</code></pre>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo5 from "../../../examples/base/component-register/demo5.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/component-register/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/component-register/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/component-register/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/component-register/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo5,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>