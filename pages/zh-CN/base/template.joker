<template>
    <div ref="container" class="joker-demo-container">
        <h2>Joker 模板概述</h2>
        <p>
            该章节主要是介绍一下 Joker SFC（单文件组件）中
            <code>&lt;template&gt;</code>
            的基础用法。Joker 使用一种基于
            <code>HTML</code>
            的模板语法，结合我们内置的动态指令，来实现一个页面的布局。
        </p>
        <p>
            在底层机制中，Joker 会将模板编译成高度优化的 （
            <a href="/base/ast" target="_blank">AST</a>
            ）JavaScript 代码。Joker 在渲染时会建立虚拟 Node 与实际渲染节点关系，以确保响应数据变更时会以最小粒度去即时更新节点信息。对于虚拟 DOM、AST 相关知识，可以在后面章节
            <a href="/base/vnode" target="_blank">虚拟节点</a>
            中进一步了解。
        </p>
        <p>
            在 Joker 中所有的动态指令都是以
            <code>@</code>
            符号开始的，我们内部提供了丰富的指令语法，包括：动态文本、条件判断、循环等，可帮助开发人员快速的进行模板布局开发。
        </p>
        <h3>动态文本</h3>
        <p>
            最基本的数据绑定形式是文本插值，它使用的是“@("@属性")”语法：
        </p>
        <pre><code class="language-html">&lt;span&gt;@value&lt;/span&gt;
</code></pre>
        <p>
            其中动态文本值，指向的属性名称对应当前组件实例的属性，可通过查看
            <a href="/base/component-property" target="_blank">组件属性</a>
            进行了解。
        </p>
        <p>除了直接去渲染一个值，我们也提供复杂的表达式：</p>
        <pre><code class="language-html">&lt;span&gt;@(isTrue?'我是内容1':'我是内容2')&lt;/span&gt;

&lt;span&gt;@(value+1)&lt;/span&gt;
</code></pre>
        <p>
            通过上面代码示例可以看到，通过
            <code>()</code>
            包裹后，即可在内部实现复杂的表达式或者运算。
        </p>
        <p>
            除了读取属性和配置表达式外，我们也可以读取
            <code>get属性</code>
            或展示一个
            <code>方法返回值</code>
            ，让我们结合组件实例看一下如何使用的。
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;span&gt;@name&lt;/span&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    export default class extends Component {
        model = {
            value: 0
        };
        get name() {
            return this.model.value + 1;
        }
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Change the value of the model.&lt;/button&gt;
    &lt;/DemoRow&gt;
    &lt;p&gt;
        @name
    &lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        value: 0
    };

    get name() {
        return &quot;Zhang San&quot; + this.model.value;
    }

    handleClick() {
        this.model.value++;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                通过上面的示例，可以看到，
                <code>get</code>
                属性内如果依赖了响应数据，当响应数据变更时，该属性也会被同步更改渲染。
            </p>
        </blockquote>
        <p>
            当然，有些场景下，虽然代码内依赖了响应数据，但是值变更没有通知模板更新，可能是因为我们的代码顺序的问题，我们必须访问过响应数据才会绑定同步关系，没有访问到则不会关联同步关系。例如：
        </p>
        <pre><code class="language-ts">export default class extends Component {
    model = {
        value: 0
    };
    get name() {
        if (false) {
            //响应数据没有被访问
            return this.model.value + 1;
        }
        return 1;
    }
}
</code></pre>
        <p>这样做的目的是，以最小的关联关系去渲染模板，避免无效的同步渲染，提高渲染性能。</p>
        <p>接下来我们再看一个展示方法返回值的场景：</p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;span&gt;@getName()&lt;/span&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    export default class extends Component {
        model = {
            value: 0
        };
        getName() {
            return this.model.value + 1;
        }
    }
&lt;/script&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;button @click=&quot;handleClick&quot;&gt;Change the value of the model.&lt;/button&gt;
    &lt;/DemoRow&gt;
    &lt;p&gt;
        @getName(&quot;Zhang San&quot;)
    &lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        value: 0
    };

    getName(preName: string) {
        return preName + this.model.value;
    }

    handleClick() {
        this.model.value++;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <p>
            通过上面的示例可以看到，我们可以在模板中直接去执行一个方法，并可以传递参数，格式为
            <code>
                @("@方法名称( 参数1 , 参数2 )")
            </code>
            。
        </p>
        <p>令人兴奋的是，方法调用也是可以支持响应数据变更带来的同步渲染机制。</p>
        <h4>关于渲染值类型（高级）</h4>
        <p>
            如果你在模板标签内容中使用
            <code>
                @("@文本")
            </code>
            进行动态文本的插入，在实际构建运行时我们会转换为
            <strong>createText('文本')</strong>
            ，无论我们通过属性取到的值时什么类型，我们都会转换为
            <code>String(value??'')</code>
            进行返回。
        </p>
        <DemoContainer component="@(components.DEMO_JOKER_demo3)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;ul&gt;
        @for(let name in testValue) {
            &lt;li&gt;
                @name
                : @testValue[name]
            &lt;/li&gt;
        }
    &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    testValue = {
        objectValue: { name: &quot;1&quot; },
        arrayValue: [1, 2, 3],
        numberValue: 1,
        undefinedValue: undefined,
        nullValue: null,
        falseValue: false,
        trueValue: true
    };
}
&lt;/script&gt;


</code></pre>
        </DemoContainer>
        <blockquote>
            <p>
                当我们在页面中使用
                <code>@</code>
                符号去读取一个字符串属性，其实我们内部会将其转换为
                <code>
                    @("@Text(属性)")
                </code>
                去渲染，你可以用 Text 指令来渲染一个属性，Text 指令是内置函数。可以查看篇尾的内置指令列表来进行了解。
            </p>
        </blockquote>
        <blockquote>
            <p>
                当需要渲染
                <code>@</code>
                符号时并后面会跟随字母时，可以使用
                <code>
                    @("@(\&quot;@\&quot;)")xxx
                </code>
                来进行表示。
            </p>
        </blockquote>
        <h3>以 HTML 渲染</h3>
        <p>
            若想将字符串内容作为
            <code>HTML</code>
            进行渲染，你可以使用内部提供的
            <code>
                @Html("&lt;p&gt;&lt;/p&gt;")
            </code>
            API 函数去渲染。
        </p>
        <blockquote>
            <p>
                默认 Html 片段会使用影子 Dom 去渲染，已实现内部样式不对外影响， 当然你可以传递第二个参数为 true，关闭影子模式。
                <code>
                    @Html("&lt;p&gt;&lt;/p&gt;", true)
                </code>
                示例：
            </p>
        </blockquote>
        <pre><code class="language-html">&lt;p&gt;@Html('&lt;span&gt;123&lt;/span&gt;')&lt;/p&gt;
&lt;p&gt;@Html(属性名)&lt;/p&gt;
</code></pre>
        <DemoContainer component="@(components.DEMO_JOKER_demo4)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;p&gt;
        I'm：@Html(&quot;&lt;b&gt;Zhang San&lt;b&gt;&quot;)
    &lt;/p&gt;
    &lt;p&gt;
        I'm：@Html(userName)
    &lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    userName = `&lt;b&gt;Zhang San&lt;b&gt;`;
}
&lt;/script&gt;


</code></pre>
        </DemoContainer>
        <h3>属性</h3>
        <p>
            <code>@</code>
            动态指令可以使用在任何地方，包括一个标签的属性：
        </p>
        <pre><code class="language-html">&lt;p style=&quot;color:@fontColor&quot;&gt;我是内容&lt;/p&gt;
&lt;input value=&quot;@inputValue&quot; type=&quot;text&quot; /&gt;
&lt;input value=&quot;我已经@(age)岁了&quot; type=&quot;text&quot; /&gt;
</code></pre>
        <p>通过上面的代码，可以看到我们可以在任意想要变更的地方去插入动态属性值。并且也可以支持响应式数据的变更。</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo5)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemorRow&gt;
        &lt;p style=&quot;color:@fontColor&quot;&gt;I'm the content&lt;/p&gt;
        &lt;div&gt;
            &lt;input value=&quot;@inputValue&quot; type=&quot;text&quot; /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input value=&quot;I'm already @(model.age) years old.&quot; type=&quot;text&quot; /&gt;
        &lt;/div&gt;
    &lt;/DemorRow&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;Increase the age&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        age: 0
    };
    fontColor = &quot;var(--jk-color-success)&quot;;
    inputValue = &quot;I'm the input content&quot;;

    handleClick() {
        this.model.age++;
    }
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <h3>组件传参</h3>
        <p>
            我们可以通过组件的参数传递，来实现组件之间的通讯，除了上面文章中提到的字符串渲染外，我们可以向组件中传递任何类型的属性，值类型取决于表达式返回的结果类型。
        </p>
        <pre><code class="language-html">&lt;my-component
    message=&quot;我是一个固定的字符串&quot;
    age=&quot;@(12)&quot;
    user-list=&quot;@(['张三','李四'])&quot;
    checked=&quot;@false&quot;
    address-info=&quot;@({city:'济南'})&quot;
    post-code=&quot;2500@(00)&quot;
/&gt;
</code></pre>
        <p>
            通过上面的例子可以看到，我们可以使用
            <code>
                @("@()")
            </code>
            的方式来进行复杂的类型表达，当然我们也可以直接指向一个属性的值。
        </p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;my-component age=&quot;@numberValue&quot; user-list=&quot;@arrayValue&quot; checked=&quot;@booleanValue&quot; address-info=&quot;@getObjectValue&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
    import { Component } from &quot;@joker.front/core&quot;;
    export default class extends Component {
        numberValue = 12;

        get arrayValue() {
            return [&quot;张三&quot;, &quot;李四&quot;];
        }

        booleanValue = false;

        getObjectValue() {
            return {
                city: &quot;济南&quot;
            };
        }
    }
&lt;/script&gt;
</code></pre>
        <p>
            针对
            <strong>boolean</strong>
            类型的值，我们对其进行了优化，只要有属性，属性不为 false 且未设置值（没有
            <code>=</code>
            ）,则按
            <strong>true</strong>
            处理。
        </p>
        <pre><code class="language-html">&lt;my-component checked /&gt;

👇👇👇等同于👇👇👇

&lt;my-component checked=&quot;@true&quot; /&gt;
</code></pre>
        <p>
            除此之外，我们针对 HTML Render 模式下的
            <code>style</code>
            和
            <code>class</code>
            进行了优化，支持传入对象/数组的形式来定义该属性的值：
        </p>
        <pre><code class="language-html">&lt;div
    style=&quot;@({
    width:'30px',
    backgroundColor:'red',
    top:false,
    height:undefined
})&quot;
&gt;&lt;/div&gt;
</code></pre>
        <p>
            我们可以指定 style 为对象类型，其中 key 类型为
            <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration" target="_blank">
                CSSStyleDeclaration
            </a>
            ，value 值为你需要配置的值，当值为 undefined/false 时，我们会移除该条 style 属性。
        </p>
        <pre><code class="language-html">&lt;div class=&quot;@(['c1','c2'])&quot;&gt;&lt;/div&gt;

&lt;div class=&quot;@({'c1':true,'c2':false})&quot;&gt;&lt;/div&gt;

&lt;div class=&quot;@([c1,c2,{ c3:true,c4:false }])&quot;&gt;&lt;/div&gt;
</code></pre>
        <p>
            <code>class</code>
            属性除了字符串外，也支持数组/对象两种形式，当为对象模式时，key 则代表需要设置的样式名称，value 值代表是否要添加该样式，只有 value 值为 true 时样式才会被添加。
        </p>
        <blockquote>
            <p>
                本小结介绍了如何向一个组件、标签去传递属性/参数，针对组件如何接收参数值，可以看
                <a href="/base/component-property" target="_blank">组件属性</a>
                中的
                <strong>props/propsOption</strong>
                内容。
            </p>
        </blockquote>
        <h3>注册全局方法</h3>
        <p>Joker 自身已经集成了非常丰富的指令方法，当然你可以扩展一些全局方法，来方便项目的快速的开发。</p>
        <pre><code class="language-html">&lt;span&gt;合计：@Global.sum(1,2)&lt;/span&gt;
</code></pre>
        <pre><code class="language-ts">import { registerGlobalFunction } from &quot;@joker.front/core&quot;;

registerGlobalFunction(&quot;sum&quot;, (ag1: number, ag2: number) =&gt; {
    return ag1 + ag2;
});
</code></pre>
        <h3>内置指令列表</h3>
        <p>下面是 Joker 内置的所有指令。</p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>指令名称</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Text</td>
                    <td>以文本插入</td>
                </tr>
                <tr>
                    <td>Html</td>
                    <td>以 HTML 格式插入</td>
                </tr>
                <tr>
                    <td>for</td>
                    <td>
                        <a href="/base/template-for" target="_blank">列表渲染</a>
                    </td>
                </tr>
                <tr>
                    <td>if</td>
                    <td>
                        <a href="/base/template-if" target="_blank">条件渲染</a>
                    </td>
                </tr>
                <tr>
                    <td>section</td>
                    <td>
                        用于
                        <strong>指定/标记</strong>
                        区块内容，
                        <a href="/base/template-section" target="_blank">区块渲染</a>
                    </td>
                </tr>
                <tr>
                    <td>RenderSection</td>
                    <td>
                        用于渲染区块内容，
                        <a href="/base/template-section" target="_blank">区块渲染</a>
                    </td>
                </tr>
                <tr>
                    <td>Global</td>
                    <td>用于调用全局注册方法</td>
                </tr>
            </tbody>
        </table>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo5 from "../../../examples/base/template/demo5.joker";
import DEMO_JOKER_demo4 from "../../../examples/base/template/demo4.joker";
import DEMO_JOKER_demo3 from "../../../examples/base/template/demo3.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/template/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/template/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo5,
        DEMO_JOKER_demo4,
        DEMO_JOKER_demo3,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>