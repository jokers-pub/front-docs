<template>
    <div ref="container" class="joker-demo-container">
        <h2>区块渲染</h2>
        <p>该章节主要介绍父子组件传值的另一种形式。</p>
        <h3>什么是区块渲染</h3>
        <p>
            父子组件除了使用
            <code>props</code>
            去传递参数外，我们也提供另一种形式的传值，我们可以将一段
            <strong>待渲染（Render）</strong>
            的内容传递到子组件，并由子组件决定该渲染模板什么时机、什么位置进行渲染。
        </p>
        <pre><code class="language-html">&lt;my-component&gt; 我是一个待渲染的内容 &lt;/my-component&gt;
</code></pre>
        <p>可以看到我们可以在自定义组件标签内容区块内来指定我们待渲染的模板区块内容。</p>
        <h3>如何使用</h3>
        <p>
            我们可以直接在组件标签内来定义
            <code>待渲染区块</code>
            的内容，也可以使用
            <code>section</code>
            指令来定义，当我们只有一个待渲染区块，并且没有渲染参数时，该指令可以被省略。
        </p>
        <pre><code class="language-xml">&lt;my-component&gt;
    &lt;p&gt;我是一个待渲染的区块模板&lt;/p&gt;
&lt;/my-component&gt;

👇👇👇等同于👇👇👇
&lt;my-component&gt;
    @section(){
        &lt;p&gt;我是一个待渲染的区块模板&lt;/p&gt;
    }
&lt;/my-component&gt;

👇👇👇等同于👇👇👇

&lt;my-component&gt;
    @section('default'){
        &lt;p&gt;我是一个待渲染的区块模板&lt;/p&gt;
    }
&lt;/my-component&gt;
</code></pre>
        <p>
            若我们不指定区块名称，则默认为
            <strong>default</strong>
            。当然，我们也可以定义多个待渲染区块：
        </p>
        <pre><code class="language-xml">&lt;my-component&gt;
    &lt;p&gt;我是一个待渲染的默认区块模板&lt;/p&gt;

    @section('top'){
        &lt;p&gt;我是一个待渲染的Top区块模板&lt;/p&gt;
    }

    &lt;p&gt;我是一个待渲染的默认区块模板（第二条）&lt;/p&gt;

    @section('bottom'){
        &lt;p&gt;我是一个待渲染的Bottom区块模板&lt;/p&gt;
    }
&lt;/my-component&gt;
</code></pre>
        <p>
            我们会将
            <strong>具有名字</strong>
            的渲染区块合并在一起，组成该名称下的渲染内容，将未指定名称的渲染区块统一合并为
            <code>default</code>
            区块。
        </p>
        <p>接下来看一下具体执行效果：</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo1)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;MyComponent&gt;
        &lt;p&gt;I'm the default rendering block (1)&lt;/p&gt;
        @section(&quot;top&quot;) {
            &lt;p&gt;I'm the top rendering block&lt;/p&gt;
        }
        &lt;p&gt;I'm the default rendering block (2)&lt;/p&gt;
        @section(&quot;bottom&quot;) {
            &lt;p&gt;I'm the bottom rendering block&lt;/p&gt;
        }
    &lt;/MyComponent&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import MyComponent from &quot;./children.joker&quot;;

export default class extends Component {
    components = {
        MyComponent
    };
}
&lt;/script&gt;

</code></pre>
        </DemoContainer>
        <p>结合上面的例子，我们看一下子组件是如何渲染这些区块的，以下是子组件代码：</p>
        <pre><code class="language-html">&lt;template&gt;
    &lt;p class=&quot;title&quot;&gt;Top区块内容：&lt;/p&gt;
    @RenderSection(&quot;top&quot;)
    &lt;p class=&quot;title&quot;&gt;正文内容：&lt;/p&gt;
    @RenderSection()
    &lt;p class=&quot;title&quot;&gt;Bottom区块内容：&lt;/p&gt;
    @RenderSection(&quot;bottom&quot;)
&lt;/template&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
    p.title {
        font-size: 18px;
        font-weight: bold;
        margin-top: 10px;
    }
&lt;/style&gt;
</code></pre>
        <p>
            通过上面代码可以发现，我们通过
            <code>RenderSection</code>
            API ，既可以实现待渲染区块模板的渲染。可以通过指定第一个参数来渲染不同的区块模板，若不传递区块名称，默认渲染
            <strong>default</strong>
            区块。
        </p>
        <h3>区块操作</h3>
        <p>
            如果你是在开发组件时，你可能会需要判断在调用该组件时，是否传入了待渲染模板，我们可以使用
            <a href="/base/component-property" target="_blank">组件属性</a>
            中的
            <code>$sections</code>
            来进行判断，例如：
        </p>
        <pre><code class="language-xml">&lt;div&gt;
    @if($sections.default){
        &lt;p&gt;@RenderSection()&lt;/p&gt;
    }
    else{
        &lt;p class=&quot;default&quot;&gt;默认信息&lt;/p&gt;
    }
&lt;/div&gt;
</code></pre>
        <p>通过上面的代码我们就可以做到，如果传入待渲染区块模板，就渲染模板，否则展示默认提示信息。</p>
        <h3>渲染参数</h3>
        <p>
            在渲染模板的过程中，某些情况下需要传递关键数据，尤其是在使用列表组件时。我们不仅需要提供列表项的渲染模板，还必须为循环中的每一项提供相应的数据，以确保渲染过程能够顺利进行。
        </p>
        <p>我们的传递参数非常直观，我们分为传参和接收参数两个代码片段来介绍下语法规则，首先是传递参数：</p>
        <pre><code class="language-xml">&lt;p&gt;
    @RenderSection('default','我是参数1',我是变量,...)
&lt;/p&gt;
</code></pre>
        <p>
            值的注意的是，如果需要传递参数，参数是从第二个参数开始的，这也就以为着我们一定要表明我们的区块名称，参数可以是静态值，也可以是组件的属性。
        </p>
        <p>接下来我们看一下在父组件如何接收子组件通过区块渲染传递的参数：</p>
        <pre><code class="language-xml">&lt;my-component&gt;
@section('default',v1,v2,v3){
    &lt;p&gt;参数1：@v1&lt;/p&gt;
    &lt;p&gt;参数2：@v2&lt;/p&gt;
}
&lt;/my-component&gt;
</code></pre>
        <p>
            通过上面代码可以看到，和传递参数一样，我们的参数也是从第二个参数开始的，参数个数和顺序对应传递参数时的规则。
        </p>
        <p>接下来看一个运行的示例：</p>
        <DemoContainer component="@(components.DEMO_JOKER_demo2)">
            <pre><code class="language-html">&lt;template&gt;
    &lt;DemoRow&gt;
        &lt;p&gt;This is an example without passing a section:&lt;/p&gt;
        &lt;ListComponent list=&quot;@list&quot;&gt;&lt;/ListComponent&gt;
    &lt;/DemoRow&gt;
    &lt;DemoRow&gt;
        &lt;p&gt;This is an example of passing a section:&lt;/p&gt;
        &lt;ListComponent list=&quot;@list&quot;&gt;
            @section(&quot;default&quot;, userName) {
                &lt;span&gt;Name: &lt;b&gt;@userName&lt;/b&gt;&lt;/span&gt;
            }
        &lt;/ListComponent&gt;
    &lt;/DemoRow&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import ListComponent from &quot;./list-component.joker&quot;;

export default class extends Component {
    components = {
        ListComponent
    };

    list = [&quot;Zhang San&quot;, &quot;Li Si&quot;, &quot;Wang Wu&quot;];
}
&lt;/script&gt;
</code></pre>
        </DemoContainer>
        <p>
            以下是
            <code>list-component</code>
            的组件示例代码：
        </p>
        <pre><code class="language-xml">&lt;template&gt;
    &lt;ul&gt;
        @for(let item of props.list) {
            &lt;li&gt;
                @if($sections.default) {
                    @RenderSection(&quot;default&quot;, item)
                }
                else {
                    @item
                }
            &lt;/li&gt;
        }
    &lt;/ul&gt;
&lt;/template&gt;
</code></pre>
        <h3>跨组件传递（高阶）</h3>
        <p>
            当有些复杂的组件开发中，父组件传入的待渲染区块模板，不一定要是该组件去执行渲染，可能会继续向下传递，由深层组件去执行模板的渲染，那这样我们就需要区块模板的
            <code>跨组件传递</code>
            了。
        </p>
        <p>
            首先我们先了解下
            <code>RenderSection</code>
            API，它的第一个参数可以是
            <strong>string</strong>
            ，也可以是
            <code>SectionType</code>
            （可以去
            <a href="/base/component-property" target="_blank">组件属性</a>
            中的
            <code>$sections</code>
            去了解），既然区块对象可以被传递，那我们就可以使用这种方式来实现跨组件的区块渲染了：
        </p>
        <pre><code class="language-xml">&lt;template&gt;
    @RenderSection(topSection,'我是参数')
&lt;/template&gt;
</code></pre>
        <pre><code class="language-ts">class extends Component{
    get topSection(){
        //向上查找，并拿到要渲染的插槽
        return this.$rootVNode.closest(...)?.component.$sections.top;

        //当然也可以作为参数传递
        return this.props.topSection;
    }
}
</code></pre>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo2 from "../../../examples/base/template-section/demo2.joker";
import DEMO_JOKER_demo1 from "../../../examples/base/template-section/demo1.joker";
export default class extends Component {
    components = {
        BottomNav,
        DEMO_JOKER_demo2,
        DEMO_JOKER_demo1
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>