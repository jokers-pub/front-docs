<template>
    <div ref="container" class="joker-demo-container">
        <h2>路由注册</h2>
        <p>该章节主要介绍如何去注册路由，并了解路由的配置规则。</p>
        <p>
            目前提供两种路由注册方式：
            <code>初始化时配置路由规则</code>
            、
            <code>动态路由注册</code>
            。
        </p>
        <h3>初始化时配置路由规则</h3>
        <p>
            我们可以在路由初始化时，通过
            <code>routes</code>
            去配置我们整个项目的所有已知路由信息。
        </p>
        <pre><code class="language-ts">import { Router } from &quot;@joker.front/rourter&quot;;

//我的区块页面
new Router({
    routes: [
        { path: &quot;/&quot;, redirect: &quot;/index&quot; },
        { path: &quot;/index&quot;, component: MyPage }
    ]
});
</code></pre>
        <h3>动态路由注册</h3>
        <p>我们提供动态路由注册方法，该方法允许我们根据环境变量、动态变量等差异去动态管理路由匹配规则的注册。</p>
        <pre><code class="language-ts">let appRouter = new Router({
    routes: [
        { path: &quot;/&quot;, redirect: &quot;/index&quot; },
        { path: &quot;/index&quot;, name:&quot;parent&quot; component: MyPage }
    ]
});

appRouter.addRoute({ path: &quot;/index&quot;, component: MyPage });

//向已知路由添加子路由
appRouter.addRoute({ path: &quot;/children&quot;, component: MyPage },'parent')
</code></pre>
        <p>该方法支持两个参数的传入：</p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>参数名称</th>
                    <th>说明</th>
                    <th>参数类型</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>route</td>
                    <td>需要添加的路由项</td>
                    <td>
                        <code>RouteRecordRaw</code>
                        ，与初始化路由配置项类型相同
                    </td>
                </tr>
                <tr>
                    <td>parentRouteName</td>
                    <td>
                        父路由节点的 name，这需要父路由是
                        <code>命名路由</code>
                        。该参数
                        <strong>可选</strong>
                        ，不配置则作为一级路由配置。
                    </td>
                    <td>
                        <code>RouteRecordName(string/symbol)</code>
                    </td>
                </tr>
            </tbody>
        </table>
        <blockquote>
            <p>
                值的注意的是，动态路由注册不允许注册一个项目的首页地址，当 Joker Router
                <strong>初始化</strong>
                时，会默认去加载当前地址/首页地址，所以通过该方法注册路由时
                <strong>需要保证在渲染该页面前注册</strong>
                。
            </p>
        </blockquote>
        <h3>路由配置项 [RouteRecordRaw]</h3>
        <p>
            <code>路由配置项</code>
            是 Joker Router 注册路由时必须要了解的数据类型，无论是初始化注册路由项还是动态注册路由，都需要按照
            <strong>RouteRecordRaw</strong>
            类型去配置路由信息。
        </p>
        <p>
            接下来的内容是
            <code>RouteRecordRaw</code>
            的相关属性说明：
        </p>
        <h3>path [匹配规则]</h3>
        <p>
            <code>path</code>
            属性用于配置路由的匹配规则，path 提供的配置规则很丰富，可以是静态的路由地址例如：
            <code>/home/index</code>
            ，也可以是动态的路由地址例如：
            <code>/user/:id</code>
            。接下来让我们详细的了解下路由的匹配规则。
        </p>
        <p>
            首先
            <code>path</code>
            属性是一个
            <code>string字符串</code>
            类型，我们可以通过配置固定的静态地址来实现路由的规则设置：
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;
        },
        {
            path: &quot;user/list&quot;
        }
    ]
});
</code></pre>
        <p>除此之外我们也可以通过表达式的方式来配置动态匹配规则：</p>
        <h4>动态参数</h4>
        <p>
            我们可以使用
            <code>:</code>
            的方式来设置我们的动态参数。其中 **:**后面的关键则代表我们动态参数的名称。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id&quot;
        }
    ]
});

/**
 * /user/abc   =&gt; true
 * /user/123   =&gt; true
 * /user       =&gt; false
 * /user/a/b   =&gt; false
 */
</code></pre>
        <p>
            当我们按上述规则配置后，当我们访问的地址
            <code>/user/abc</code>
            、
            <code>/user/123</code>
            等场景时都会被认为符合当前路由匹配规则。
        </p>
        <p>
            在实际页面加载后，我们会将
            <code>/user/</code>
            后面的内容作为参数传递到
            <a href="/router/route" target="_blank">路由信息</a>
            中的参数中，并将参数命名为
            <strong>id</strong>
            。
        </p>
        <p>
            当我们访问
            <code>/user</code>
            或者
            <code>/user/abc/xxx</code>
            时，则该路由规则
            <strong>不会被匹配</strong>
            ，因为
            <code>:</code>
            动态规则只配置了一次并不可重复。
        </p>
        <h4>正则约束</h4>
        <p>
            我们允许在
            <code>:</code>
            动态参数后添加该参数的正则匹配规则，你可以在
            <code>()</code>
            内配置该参数的正则规则，例如：
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id(\\d+)&quot;
        }
    ]
});

/**
 * /user/abc   =&gt;  false
 * /user/123   =&gt;  true
 */
</code></pre>
        <h4>动态拼接</h4>
        <p>动态参数可以和静态字符进行拼接来实现复杂的地址匹配规则，例如：</p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/:id([0-9]{2})hello&quot;
        }
    ]
});

/**
 * /home/12hello   =&gt;  true
 * /home/123hello  =&gt;  false
 */
</code></pre>
        <p>
            值的注意的是，虽然在表达式中使用了
            <code>动态+静态</code>
            的拼接，我们会在地址参数转换时正确的拆解参数变量，例如
            <code>/home/12hello</code>
            ，拆解后的参数
            <strong>id='12'</strong>
            。
        </p>
        <h4>可选参数</h4>
        <p>
            当我们需要对一个参数实现可选时，我们可以在变量后面添加
            <code>?</code>
            来实现，
            <strong>它代表参数可选，而不是正则表达式的约束规则</strong>
            。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id?&quot;
        }
    ]
});

/**
 * /user/abc   =&gt; true
 * /user       =&gt; true
 * /user/a/b   =&gt; false
 */
</code></pre>
        <p>
            带参数的时候需要在
            <code>()</code>
            后添加
            <strong>?</strong>
            。
        </p>
        <pre><code class="language-ts">new Router({
    routers: [
        {
            path: &quot;/user/:id(\\d{2})?&quot;
        }
    ]
});

/**
 * /user/12   =&gt; true
 * /user      =&gt; true
 * /user/1    =&gt; false
 * /user/123  =&gt; false
 * /user/1/2  =&gt; false
 */
</code></pre>
        <h4>可循环</h4>
        <p>
            我们可以在动态参数后添加
            <code>+</code>
            /
            <code>*</code>
            来表示该参数可循环多次。其中
            <code>+</code>
            代表至少循环一次，
            <code>*</code>
            代表可循环+可选。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id(\\d+)+&quot;
        }
    ]
});

/**
 * /user/1     =&gt; true
 * /user/1a    =&gt; false
 * /user/1/2/3 =&gt; true
 * /user       =&gt; false
 * /user/1/b   =&gt; false
 */
</code></pre>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id*&quot;
        }
    ]
});

/**
 * /user/abc   =&gt; true
 * /user       =&gt; true
 * /user/a/b   =&gt; true
 */
</code></pre>
        <p>下面是复杂的静态字符拼接示例：</p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user:id+&quot;
        }
    ]
});

/**
 * /userabc   =&gt; true  参数为abc
 * /user       =&gt; false
 */
</code></pre>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/:id(d+)+user&quot;
        }
    ]
});

/**
 * /123user   =&gt; true  参数为123
 * /123+user  =&gt; false '+'为变量修饰符
 */
</code></pre>
        <h4>可循环+可选 [*]</h4>
        <p>
            当我们配置
            <code>*</code>
            修饰符时，代表该变量为可选并且可循环。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user/:id*&quot;
        }
    ]
});

/**
 * /user/abc   =&gt; true
 * /user       =&gt; true
 * /user/a/b   =&gt; true
 */
</code></pre>
        <h3>redirect [重定向]</h3>
        <p>
            我们可以通过配置
            <code>redirect</code>
            属性来实现路由重定向。
        </p>
        <pre><code class="language-js">new Router({
    routes: [
        {
            path: &quot;/&quot;,
            redirect: &quot;/home/index&quot;
        }
    ]
});
</code></pre>
        <p>
            上面的代码代表当我们没有任何地址时，会重定向到
            <code>/home/index</code>
            。
            当我们配置
            <strong>redirect</strong>
            ，除了支持字符串类型的值外，还支持方法重定向和支持更多配置的路由配置。
        </p>
        <p>更丰富的配置：</p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/&quot;,
            redirect: {
                name: &quot;命名路由&quot;,
                params: { value: &quot;1&quot; }
            }
        },
        {
            path: &quot;/&quot;,
            redirect: {
                hash: &quot;/home/index&quot;,
                query: { value: &quot;1&quot; }
            }
        },
        {
            path: &quot;/&quot;,
            redirect: {
                path: &quot;/home/index&quot;
            }
        }
    ]
});
</code></pre>
        <p>
            自定义方法，该方法会传入目前的路由信息，并需要返回一个新的路由，返回的类型请参考上面的
            <strong>更丰富的配置</strong>
            提供的规范格式：
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/&quot;,
            redirect: (to: RouteLocationBase) =&gt; {
                return {
                    name: &quot;命名路由&quot;,
                    params: { value: &quot;1&quot; }
                };
            }
        }
    ]
});
</code></pre>
        <h3>name [命名路由]</h3>
        <p>
            我们可以为一个路由配置项添加一个
            <code>name</code>
            属性，来为其进行命名，命名后的路由可以在跳转、添加路由等操作时，通过
            <strong>name</strong>
            快速的去设置。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            name: &quot;home&quot;
        }
    ]
});
</code></pre>
        <h3>alias 路由匹配别名</h3>
        <p>
            <code>alias</code>
            可用于对匹配地址的补充，也可以理解为对
            <code>path</code>
            匹配规则的别名。他可以配置一个字符串，也可以配置为字符串数组。值遵循
            <code>path</code>
            类型规范。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            alias: &quot;/home&quot;
        },
        {
            path: &quot;/user/list&quot;,
            alias: [&quot;/user&quot;, &quot;/u/list&quot;, &quot;/user/all&quot;]
        }
    ]
});
</code></pre>
        <h3>meta [路由元数据]</h3>
        <p>
            <code>meta</code>
            作为路由的元数据属性，用于存储路由的自定义数据。配置元数据后我们可以在路由切面事件、路由信息中拿到这些数据做相应的业务操作。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            meta: {
                param: &quot;v1&quot;
            }
        }
    ]
});
</code></pre>
        <p>如何使用：</p>
        <pre><code class="language-ts">let appRouter = new Router({
    //...
});

appRouter.beforeRouteCallbacks.add((to, from) =&gt; {
    if (to.meta.param === &quot;v1&quot;) {
        //TODO:
    }
});
</code></pre>
        <p>
            或者在组件内通过
            <code>router</code>
            信息取值，详细可参考
            <a href="/router/route" target="_blank">路由信息</a>
            。
        </p>
        <pre><code class="language-ts">import { router } from &quot;@joker.front/router&quot;;

if (router.route.value.meta.param === &quot;v1&quot;) {
    //TODO:
}
</code></pre>
        <h3>children [子路由]</h3>
        <p>
            通过配置
            <code>children</code>
            可以配置当前路由的子路由项，这也就是我们通常说的
            <code>嵌套路由</code>
            。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user&quot;,
            component: MyComponent,
            children: [
                { path: &quot;list&quot;, component: userListComponent },
                { path: &quot;info&quot;, component: userInfoComponent }
            ]
        }
    ]
});
</code></pre>
        <p>
            通过上面例子可以看出，我们创建了一个
            <code>/user</code>
            路由，该路由下又存在两个子路由，若他们的
            <strong>path</strong>
            属性不是
            <code>/</code>
            开头，则按照拼接的方式进行子路由匹配规则的配置(
            <strong>父路由 path/子路由 path</strong>
            )。
        </p>
        <ul>
            <li>/user/list</li>
            <li>/user/info</li>
        </ul>
        <p>
            当子路由
            <strong>path</strong>
            规则以 **/**开头，则忽略父路由 path 配置，例如：
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/user&quot;,
            component: MyComponent,
            children: [
                { path: &quot;/user/list&quot;, component: userListComponent },
                { path: &quot;/user/info&quot;, component: userInfoComponent }
            ]
        }
    ]
});
</code></pre>
        <p>
            上面例子最终也会解析为
            <code>/user/list</code>
            、
            <code>/user/info</code>
            两个路由。
        </p>
        <p>
            <a href="/router/nested-routes" target="_blank">嵌套路由</a>
            后续会有单独的章节进行详细介绍。
        </p>
        <h3>component/components [路由组件]</h3>
        <p>
            我们可以通过
            <code>component/components</code>
            这两个属性来配置当前路由需要装载的视图组件。他们两个的区别是：
        </p>
        <ul>
            <li>
                <code>component</code>
                ：当前路由只需要装载一个组件，也可以理解为布局文件中只有一个
                <code>&lt;router-view&gt;</code>
                标签。
            </li>
            <li>
                <code>components</code>
                : 当前路由需要装载多个组件，布局文件中存在多个命名容器
                <code>&lt;router-view&gt;</code>
                。
            </li>
        </ul>
        <p>
            <code>&lt;router-view&gt;</code>
            ，可通过查看
            <a href="/router/router-view" target="_blank">动态容器</a>
            去学习了解。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent
        },
        {
            path: &quot;/user/index&quot;,
            components: {
                top: userTopComponent,
                bottom: userBottomComponent
            }
        }
    ]
});
</code></pre>
        <p>
            当然
            <code>component/components</code>
            也支持异步懒加载组件：
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: () =&gt; import(&quot;index.joker&quot;)
        },
        {
            path: &quot;/user/index&quot;,
            components: {
                top: userTopComponent,
                bottom: () =&gt; import(&quot;./user/bottom.joker&quot;)
            }
        }
    ]
});
</code></pre>
        <h3>props [组件参数]</h3>
        <p>
            <code>props</code>
            属性一般用作为
            <code>component/components</code>
            组件进行参数配置的，我们在
            <strong>props</strong>
            中配置的参数，会在组件初始化时作为
            <code>props</code>
            进行传递，可以在
            <a href="/base/component-property" target="_blank">组件属性</a>
            中的 props 进行了解。
        </p>
        <p>
            props 属性会的配置需要根据
            <code>component/components</code>
            的不同而进行不同规则的配置，当我们使用
            <code>component</code>
            单个组件时，我们的 props 既是组件的中的 props 的类型约束：
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            props: {
                p1: &quot;v1&quot;
            }
        }
    ]
});
</code></pre>
        <p>
            当我们使用
            <code>components</code>
            时，那 props 则应该找
            <code>components</code>
            中的
            <strong>key</strong>
            进行区分，以便在运行时我们可以知道当前 props 是要传递给哪个组件：
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            components: {
                top: topComponent,
                bottom: bottomComponent
            },
            props: {
                top: {
                    p1: &quot;v1&quot;
                }
            }
        }
    ]
});
</code></pre>
        <p>
            props 除了可以指定静态的对象，也可以定义为函数类型，并在渲染时根据要渲染地址自定义转换 props 的值，
            <code>component/components</code>
            两种方式对 props 函数的支持是一样的：
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            props: (to) =&gt; {
                //TODO:  使用to来进行业务判断
                return {
                    message: &quot;我是参数&quot;
                };
            }
        }
    ]
});
</code></pre>
        <h3>beforeEnter [进入路由前 HOOK]</h3>
        <p>
            <code>beforeEnter</code>
            作为当前路由的
            <strong>hook</strong>
            ，当路由匹配成功即将进行路由渲染前，该方法会被执行。
        </p>
        <p>
            当然我们使用
            <code>Router</code>
            的全局事件也可以实现进入路由前的定制化业务处理，该
            <strong>hook</strong>
            作为 route 项，在路由配置项层提供简单的 hook 能力。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeEnter: (to, from, next) =&gt; {
                //TODO:
            }
        },
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeEnter: [
                (to, from) =&gt; {
                    //TODO：
                },
                (to, from) =&gt; {
                    //TODO：
                }
            ]
        }
    ]
});
</code></pre>
        <p>
            关于
            <code>hook</code>
            函数类型，可参考
            <a href="/router/event" target="_blank">组件事件</a>
            ，他们都是遵循
            <strong>NavigationCallback</strong>
            类型规范。
        </p>
        <h3>beforeLeave [跳出路由前 HOOK]</h3>
        <p>
            <code>beforeLeave</code>
            作为当前路由的
            <strong>hook</strong>
            ，当路由跳出前，该方法会被执行。
        </p>
        <p>
            当然我们使用
            <code>Router</code>
            的全局事件也可以实现进入路由前的定制化业务处理，该
            <strong>hook</strong>
            作为 route 项，在路由配置项层提供简单的 hook 能力。
        </p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeLeave: (to, from, next) =&gt; {
                //TODO:
            }
        },
        {
            path: &quot;/home/index&quot;,
            component: IndexComponent,
            beforeLeave: [
                (to, from) =&gt; {
                    //TODO：
                },
                (to, from) =&gt; {
                    //TODO：
                }
            ]
        }
    ]
});
</code></pre>
        <p>
            关于
            <code>hook</code>
            函数类型，可参考
            <a href="/router/event" target="_blank">组件事件</a>
            ，他们都是遵循
            <strong>NavigationCallback</strong>
            类型规范。
        </p>
        <h3>keepalive [状态保持]</h3>
        <p>当前路由跳出时，已加载的视图组件是否要保持状态，以便在返回时恢复到保留状态时的组件。</p>
        <p>
            关于保持状态，建议先了解
            <a href="/base/component-lifecycle" target="_blank">组件生命周期</a>
            。
        </p>
        <p>
            路由中的
            <code>keepalive</code>
            属性支持多种配置类型，不同的配置类型代表的含义不同（
            <strong>默认 undefined</strong>
            ）：
        </p>
        <ul>
            <li>
                <p>
                    <code>true</code>
                    : 一直保持存活，可以通过
                    <a href="/router/change" target="_blank">跳转</a>
                    时使用
                    <strong>refresh</strong>
                    属性进行缓存销毁刷新。
                </p>
            </li>
            <li>
                <p>
                    <code>'once'</code>
                    :代表只存活一次，该组件只会从缓存中渲染一次，第二次渲染时则按照新组件执行，一般适用于
                    <code>高频访问+低频更新</code>
                    的路由节点。
                </p>
            </li>
            <li>
                <p>
                    <code>false/undefined</code>
                    : 代表不做状态保持。
                </p>
            </li>
        </ul>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/product/index&quot;,
            component: IndexComponent,
            keepalive: &quot;once&quot;
        }
    ]
});
</code></pre>
        <p>
            更多的使用方式，可通过
            <a href="/router/keepalive" target="_blank">状态保持</a>
            进行学习了解。
        </p>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>