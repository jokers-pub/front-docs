<template>
    <div ref="container" class="joker-demo-container">
        <h2>滚动行为</h2>
        <p>
            Joker Router 内部提供了页面跳转后的滚动条交互 HOOK，我们可以利用这个参数来实现页面切换时对滚动条位置的精确控制。
        </p>
        <h3>如何使用</h3>
        <p>
            我们可以在初始化 Router 时通过
            <code>scrollBehavior</code>
            属性来配置我们的滚动条行为，该 HOOK 作为全局路由切面，在路由跳转完毕后触发该方法。
        </p>
        <pre><code class="language-ts">import { Router } from &quot;@joker.front/rourter&quot;;

new Router({
    scrollBehavior: (to, from, savePosition) =&gt; {
        //路由跳转后滚动条自定义操作方法
    }
});
</code></pre>
        <h3>参数说明</h3>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>参数名称</th>
                    <th>说明</th>
                    <th>类型</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>to</td>
                    <td>目标地址</td>
                    <td>RouteLocation</td>
                </tr>
                <tr>
                    <td>from</td>
                    <td>来源地址</td>
                    <td>RouteLocation</td>
                </tr>
                <tr>
                    <td>savePosition</td>
                    <td>目标地址已保存的滚动条位置信息（第一次时该值为 undefined）</td>
                    <td>ScrollPosition / undefined</td>
                </tr>
            </tbody>
        </table>
        <h3>返回类型</h3>
        <p>
            <code>scrollBehavior</code>
            提供了多种返回类型，每种类型都对应着不同的处理逻辑，以确保页面跳转时滚动条的行为符合预期。
        </p>
        <pre><code class="language-ts">export type RouteScrollBehavior = (
    to: RouteLocation,
    from: RouteLocation,
    savedPosition: ScrollPosition | undefined
) =&gt; Awaitable&lt;ScrollPosition | false | void&gt;;
</code></pre>
        <p>
            首先该 HOOK 是支持
            <code>Promise</code>
            操作的，并且根据返回值不同有不同的行为操作。
        </p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>返回类型</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>ScrollPosition</td>
                    <td>
                        返回新的 scroll 值，Joker Router 会根据返回的值执行
                        <code>window.scrollTo</code>
                    </td>
                </tr>
                <tr>
                    <td>false</td>
                    <td>不需要进行 scroll 操作</td>
                </tr>
                <tr>
                    <td>undefined</td>
                    <td>不需要进行 scroll 操作</td>
                </tr>
            </tbody>
        </table>
        <h3>ScrollPosition</h3>
        <p>
            我们可以返回
            <code>ScrollPosition</code>
            类型数据，以便让 Joker Router 去控制滚动条行为。
        </p>
        <ol>
            <li>
                返回
                <code>top</code>
                /
                <code>left</code>
                ，来控制 window 滚动条。
            </li>
        </ol>
        <pre><code class="language-ts">new Router({
    scrollBehavior: (to, from, savePosition) =&gt; {
        return {
            top: 0,
            left: 0
        };
    }
});
</code></pre>
        <ol start="2">
            <li>
                设置元素
                <code>Element</code>
                ，使其滚动到该元素的位置。
            </li>
        </ol>
        <pre><code class="language-ts">new Router({
    scrollBehavior: (to, from, savePosition) =&gt; {
        return {
            el: document.getElementById(&quot;main&quot;)
        };
    }
});
</code></pre>
        <h3>延迟滚动</h3>
        <p>
            在某些场景下，你可能需要在页面滚动前等待一段时间，比如在过渡效果期间，以确保过渡完全结束后再进行滚动。为了实现这一点，你可以返回一个 Promise，该 Promise 在解决时提供所需的位置描述符。以下是一个示例，其中我们在滚动之前等待了 500 毫秒：
        </p>
        <pre><code class="language-ts">new Router({
    scrollBehavior: async (to, from, savePosition) =&gt; {
        await sleep(500);

        return {
            top: 0
        };
    }
});
</code></pre>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>