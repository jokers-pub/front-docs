<template>
    <div ref="container" class="joker-demo-container">
        <h2>路由信息</h2>
        <p>该章节主要介绍我们如何获取当前的路由信息，路由信息里面包含哪些属性。</p>
        <h3>如何使用</h3>
        <p>
            我们可以在 Joker Router 初始化实例，或者
            <code>router</code>
            中获取
            <strong>route</strong>
            对象，该对象即我们当前的路由信息。
        </p>
        <pre><code class="language-ts">import { router } from &quot;@joker.front/router&quot;;

//获取route
router.route;
</code></pre>
        <h3>如何监听路由变更</h3>
        <p>
            值得注意的是，
            <code>router.route</code>
            对象是一个
            <code>ShallowObserver 数据浅代理劫持</code>
            对象，对该功能不熟悉的同学，可以去
            <a href="/base/observer" target="_blank">数据代理</a>
            中学习。
        </p>
        <p>
            由于该对象是一个响应式数据，我们可以通过
            <a href="/base/watcher" target="_blank">订阅</a>
            数据变更来判断当前路由的变更。
        </p>
        <pre><code class="language-ts">new Watcher(
    () =&gt; router.route.value,
    () =&gt; {
        //路由变更了
    }
);
</code></pre>
        <h3>属性列表</h3>
        <p>
            以下是
            <code>route</code>
            的数据列表：
        </p>
        <table class="mkd-table">
            <thead>
                <tr>
                    <th>属性名</th>
                    <th>说明</th>
                    <th>类型</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>name</td>
                    <td>命名路由的 name 值</td>
                    <td>string / symbol</td>
                </tr>
                <tr>
                    <td>path</td>
                    <td>最终访问的地址(对应 router 配置中的 path，区别在于该值不包含动态参数，是被反编译后的字符串)</td>
                    <td>string</td>
                </tr>
                <tr>
                    <td>fullPath</td>
                    <td>完整的访问地址</td>
                    <td>string</td>
                </tr>
                <tr>
                    <td>query</td>
                    <td>URL Query 参数</td>
                    <td>object</td>
                </tr>
                <tr>
                    <td>hash</td>
                    <td>浏览器 hash 值</td>
                    <td>string</td>
                </tr>
                <tr>
                    <td>params</td>
                    <td>页面参数</td>
                    <td>object</td>
                </tr>
                <tr>
                    <td>meta</td>
                    <td>路由数据元，用于存储当前路由项的一些静态值</td>
                    <td>object</td>
                </tr>
                <tr>
                    <td>redirectedFrom</td>
                    <td>重定向来源</td>
                    <td>RouteLocationBase/undefined</td>
                </tr>
                <tr>
                    <td>matched</td>
                    <td>当前地址匹配到的路由记录集合</td>
                    <td>RouteRecord[]</td>
                </tr>
            </tbody>
        </table>
        <h3>matched [匹配路由集合]</h3>
        <p>
            为了深入理解
            <code>matched</code>
            这一概念，我们需要仔细探讨其原理。接下来，我将通过一个具体例子来详细解释
            <code>matched</code>
            的工作机制。
        </p>
        <p>当我们存在嵌套路由场景时，例如：</p>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/base&quot;,
            component: ChildrenLayout,
            childrens: [
                { path: &quot;page1&quot;, component: () =&gt; import(&quot;./page1.joker&quot;) },
                { path: &quot;page2&quot;, component: () =&gt; import(&quot;./page2.joker&quot;) }
            ]
        }
    ]
});
</code></pre>
        <p>
            当我们访问
            <code>/base/page1</code>
            时， 当前路由的
            <code>matched</code>
            会包含两条记录，分别是：
        </p>
        <pre><code class="language-ts">[
    {
        path: &quot;/base&quot;
        //...
    },
    {
        path: &quot;page1&quot;
        //...
    }
];
</code></pre>
        <p>
            从这个例子可以看出
            <code>matched</code>
            存放的是当前路由匹配到所有路由项记录，并按照层级按顺序进行记录。
        </p>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>