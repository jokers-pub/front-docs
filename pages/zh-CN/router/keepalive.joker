<template>
    <div ref="container" class="joker-demo-container">
        <h2>路由状态保持 [keepalive]</h2>
        <p>本章主要介绍下路由状态保持是什么，以及我们如何去使用它。</p>
        <h3>什么是路由状态保持</h3>
        <p>
            在开发单页面应用程序（SPA）时，我们常遇到用户从一个列表页面切换到详情页面的情况。返回列表页面时，我们希望保持列表的查询条件、分页状态及其他交互特性不变，避免重新渲染整个列表页面。这个时候就需要我们对某一个页面做路由状态保持，以便它在跳出时不被完整销毁。
        </p>
        <h3>如何使用</h3>
        <p>
            我们可以在路由注册时配置该路由项的
            <code>keepalive</code>
            项，将该属性设置为
            <code>true</code>
            /
            <code>'once'</code>
            即可实现路由的状态保持。不同的配置类型代表的含义不同（
            <strong>默认 undefined</strong>
            ）：
        </p>
        <ul>
            <li>
                <p>
                    <code>true</code>
                    : 一直保持存活，可以通过
                    <a href="/router/change" target="_blank">跳转</a>
                    时使用
                    <strong>refresh</strong>
                    属性进行缓存销毁刷新。
                </p>
            </li>
            <li>
                <p>
                    <code>'once'</code>
                    :代表只存活一次，该组件只会从缓存中渲染一次，第二次渲染时则按照新组件执行，一般适用于
                    <code>高频访问+低频更新</code>
                    的路由节点。
                </p>
            </li>
            <li>
                <p>
                    <code>false/undefined</code>
                    : 代表不做状态保持。
                </p>
            </li>
        </ul>
        <pre><code class="language-ts">new Router({
    routes: [
        {
            path: &quot;/product/index&quot;,
            component: IndexComponent,
            keepalive: true
        }
    ]
});
</code></pre>
        <h3>如何清除状态</h3>
        <p>
            当我们需要刷新已经保持状态的页面时，我们可以通过
            <code>push</code>
            方法中的
            <strong>refresh:true</strong>
            来刷新目标路由的缓存状态。
        </p>
        <pre><code class="language-ts">push({
    path: &quot;#product/list&quot;,
    refresh: true
});
</code></pre>
        <blockquote>
            <p>
                当然你也可以不清除缓存使用
                <code>sleeped、wakeup</code>
                两个
                <a href="/base/component-lifecycle" target="_blank">生命周函数</a>
                去实现组件内的数据刷新操作。使用
                <code>refresh</code>
                可以实现缓存的组件实例的销毁和重新创建。
            </p>
        </blockquote>
        <h3>once 使用场景</h3>
        <p>
            首先当我们配置
            <code>keepalive</code>
            等于
            <strong>once</strong>
            时，该页面只会被缓存一次，我们可以在以下场景下通过
            <code>once</code>
            来实现比较高效简单的状态保持功能。
        </p>
        <ol>
            <li>该页面是一个高频访问/低频更新的页面，我们可以使用 once 来减少页面渲染次数。</li>
            <li>
                如果我们的下一级路由只能返回到当前页面，也就是说当前的页面链条是单一的，那么我们可以使用
                <code>once</code>
                来实现状态保持。
            </li>
        </ol>
        <p>
            其中在链条单一的模式下，我们使用 once，可以免去我们跳转时的
            <code>refresh</code>
            ，因为当我们在此正序访问该页面时，该页面已经不存在缓存状态了。
        </p>
        <p>当然，你也可以根据这种缓存策略拓展出更多应用场景，等待你去探索和发掘。</p>
        <p>
            有些同学可能会有疑问，为什么不可以根据路由跳转方向主动清除缓存。实际上，浏览器在处理跳转时并不会让我们获取到用户的交互历史，因此我们无法确定当前的跳转是用户返回还是前往新的页面。
        </p>
        <p>
            尽管我们可以在
            <code>window</code>
            对象中设置一个全局变量来记录每次路由变更的情况，以此在下次跳转时判断历史记录中是否存在目标地址，从而判断是回退还是前进。但这种方法并不可取，因为相同的地址可能既是一次回退，也可能是一个全新的业务节点。不同的页面可能跳转到相同的地址，但它们所代表的业务逻辑是不同的。因此，我们不推荐通过自定义历史记录的方式来管理路由的跳转方向。
        </p>
        <p>
            因此，在处理复杂的路由跳转场景时，我们建议采用
            <code>refresh</code>
            属性来决定是否清除缓存状态，这样的方法更为灵活和可控。
        </p>
        <BottomNav />
    </div>
</template>

<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
    components = {
        BottomNav
    };
    mounted() {
        let container = this.$getRef("container")?.output!;
        container.querySelectorAll("pre code").forEach((el: HTMLElement) => {
            hljs.highlightElement(el);
        });
    }
}

</script>